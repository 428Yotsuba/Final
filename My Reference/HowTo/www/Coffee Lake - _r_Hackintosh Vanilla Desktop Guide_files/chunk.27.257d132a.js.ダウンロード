(window.__LOADABLE_LOADED_CHUNKS__=window.__LOADABLE_LOADED_CHUNKS__||[]).push([[27],{12:function(e,t,s){"use strict";s.r(t),s.d(t,"Block",function(){return P}),s.d(t,"Change",function(){return We}),s.d(t,"Changes",function(){return Je}),s.d(t,"Character",function(){return Y}),s.d(t,"Data",function(){return I}),s.d(t,"Document",function(){return $}),s.d(t,"History",function(){return ke}),s.d(t,"Inline",function(){return D}),s.d(t,"Leaf",function(){return Q}),s.d(t,"Mark",function(){return R}),s.d(t,"Node",function(){return te}),s.d(t,"Operation",function(){return Ee}),s.d(t,"Operations",function(){return qe}),s.d(t,"Range",function(){return H}),s.d(t,"Schema",function(){return Ke}),s.d(t,"Stack",function(){return Oe}),s.d(t,"Text",function(){return ee}),s.d(t,"Value",function(){return we}),s.d(t,"resetKeyGenerator",function(){return z}),s.d(t,"setKeyGenerator",function(){return j});var r=s(94),n=s.n(r);s.d(t,"resetMemoization",function(){return r.resetMemoization}),s.d(t,"useMemoization",function(){return r.useMemoization});var o=s(60),a=s.n(o),i=s(35),c=s(4),l=s(386),d=s.n(l),u=s(333),h=s.n(u),f=s(1020),y=s.n(f),g=s(802),m=s(803),p=s.n(m),k=s(696),v=s.n(k),A=s(19),O=s(804),x=s.n(O),B=s(663),K=s.n(B);function T(e,t,s){return t in e?Object.defineProperty(e,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[t]=s,e}function b(e){for(var t=1;t<arguments.length;t++){var s=null!=arguments[t]?arguments[t]:{},r=Object.keys(s);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(s).filter(function(e){return Object.getOwnPropertyDescriptor(s,e).enumerable}))),r.forEach(function(t){T(e,t,s[t])})}return e}function S(e,t){if(null==e)return{};var s,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)s=o[r],t.indexOf(s)>=0||(n[s]=e[s]);return n}const w={BLOCK:"@@__SLATE_BLOCK__@@",CHANGE:"@@__SLATE_CHANGE__@@",CHARACTER:"@@__SLATE_CHARACTER__@@",DOCUMENT:"@@__SLATE_DOCUMENT__@@",HISTORY:"@@__SLATE_HISTORY__@@",INLINE:"@@__SLATE_INLINE__@@",LEAF:"@@__SLATE_LEAF__@@",MARK:"@@__SLATE_MARK__@@",OPERATION:"@@__SLATE_OPERATION__@@",RANGE:"@@__SLATE_RANGE__@@",SCHEMA:"@@__SLATE_SCHEMA__@@",STACK:"@@__SLATE_STACK__@@",TEXT:"@@__SLATE_TEXT__@@",VALUE:"@@__SLATE_VALUE__@@"};function N(e,t){return!(!t||!t[w[e]])}let E,F;function L(){return F()}function j(e){F=e}function z(){E=0,F=(()=>`${E++}`)}z();const C={data:new c.Map,isVoid:!1,key:void 0,nodes:new c.List,type:void 0};class P extends(Object(c.Record)(C)){static create(e){if(void 0===e&&(e={}),P.isBlock(e))return e;if("string"==typeof e&&(e={type:e}),a()(e))return P.fromJS(e);throw new Error(`\`Block.create\` only accepts objects, strings or blocks, but you passed it: ${e}`)}static createList(e){if(void 0===e&&(e=[]),c.List.isList(e)||Array.isArray(e)){return new c.List(e.map(P.create))}throw new Error(`\`Block.createList\` only accepts arrays or lists, but you passed it: ${e}`)}static fromJS(e){if(P.isBlock(e))return e;const t=e.data,s=void 0===t?{}:t,r=e.isVoid,n=void 0!==r&&r,o=e.key,a=void 0===o?L():o,i=e.nodes,l=void 0===i?[]:i,d=e.type;if("string"!=typeof d)throw new Error("`Block.fromJS` requires a `type` string.");return new P({key:a,type:d,isVoid:!!n,data:Object(c.Map)(s),nodes:P.createChildren(l)})}static fromJSON(e){return i.a.deprecate("slate@0.35.0","fromJSON methods are deprecated, use fromJS instead"),P.fromJS(e)}static isBlockList(e){return c.List.isList(e)&&e.every(e=>P.isBlock(e))}get object(){return"block"}get kind(){return i.a.deprecate("slate@0.32.0","The `kind` property of Slate objects has been renamed to `object`."),this.object}get isEmpty(){return!this.isVoid&&!this.nodes.some(e=>!e.isEmpty)}get text(){return this.getText()}toJS(e){void 0===e&&(e={});const t={object:this.object,type:this.type,isVoid:this.isVoid,data:this.data.toJS(),nodes:this.nodes.toArray().map(t=>t.toJS(e))};return e.preserveKeys&&(t.key=this.key),t}toJSON(e){return i.a.deprecate("slate@0.35.0","toJSON methods are deprecated, use toJS instead"),this.toJS(e)}}T(P,"isBlock",N.bind(null,"BLOCK")),P.prototype[w.BLOCK]=!0;const _={data:new c.Map,isVoid:!1,key:void 0,nodes:new c.List,type:void 0};class D extends(Object(c.Record)(_)){static create(e){if(void 0===e&&(e={}),D.isInline(e))return e;if("string"==typeof e&&(e={type:e}),a()(e))return D.fromJS(e);throw new Error(`\`Inline.create\` only accepts objects, strings or inlines, but you passed it: ${e}`)}static createList(e){if(void 0===e&&(e=[]),c.List.isList(e)||Array.isArray(e)){return new c.List(e.map(D.create))}throw new Error(`\`Inline.createList\` only accepts arrays or lists, but you passed it: ${e}`)}static fromJS(e){if(D.isInline(e))return e;const t=e.data,s=void 0===t?{}:t,r=e.isVoid,n=void 0!==r&&r,o=e.key,a=void 0===o?L():o,i=e.nodes,l=void 0===i?[]:i,d=e.type;if("string"!=typeof d)throw new Error("`Inline.fromJS` requires a `type` string.");return new D({key:a,type:d,isVoid:!!n,data:new c.Map(s),nodes:D.createChildren(l)})}static fromJSON(e){return i.a.deprecate("slate@0.35.0","fromJSON methods are deprecated, use fromJS instead"),D.fromJS(e)}static isInlineList(e){return c.List.isList(e)&&e.every(e=>D.isInline(e))}get object(){return"inline"}get kind(){return i.a.deprecate("slate@0.32.0","The `kind` property of Slate objects has been renamed to `object`."),this.object}get isEmpty(){return!this.isVoid&&!this.nodes.some(e=>!e.isEmpty)}get text(){return this.getText()}toJS(e){void 0===e&&(e={});const t={object:this.object,type:this.type,isVoid:this.isVoid,data:this.data.toJS(),nodes:this.nodes.toArray().map(t=>t.toJS(e))};return e.preserveKeys&&(t.key=this.key),t}toJSON(e){return i.a.deprecate("slate@0.35.0","toJSON methods are deprecated, use toJS instead"),this.toJS(e)}}T(D,"isInline",N.bind(null,"INLINE")),D.prototype[w.INLINE]=!0;class I{static create(e){if(void 0===e&&(e={}),c.Map.isMap(e))return e;if(a()(e))return I.fromJS(e);throw new Error(`\`Data.create\` only accepts objects or maps, but you passed it: ${e}`)}static fromJS(e){return new c.Map(e)}static fromJSON(e){return i.a.deprecate("slate@0.35.0","fromJSON methods are deprecated, use fromJS instead"),I.fromJS(e)}}const J={data:new c.Map,type:void 0};class R extends(Object(c.Record)(J)){static create(e){if(void 0===e&&(e={}),R.isMark(e))return e;if("string"==typeof e&&(e={type:e}),a()(e))return R.fromJS(e);throw new Error(`\`Mark.create\` only accepts objects, strings or marks, but you passed it: ${e}`)}static createSet(e){if(c.Set.isSet(e)||Array.isArray(e)){return new c.Set(e.map(R.create))}if(null==e)return Object(c.Set)();throw new Error(`\`Mark.createSet\` only accepts sets, arrays or null, but you passed it: ${e}`)}static createProperties(e){if(void 0===e&&(e={}),R.isMark(e))return{data:e.data,type:e.type};if("string"==typeof e)return{type:e};if(a()(e)){const t={};return"type"in e&&(t.type=e.type),"data"in e&&(t.data=I.create(e.data)),t}throw new Error(`\`Mark.createProperties\` only accepts objects, strings or marks, but you passed it: ${e}`)}static fromJS(e){const t=e.data,s=void 0===t?{}:t,r=e.type;if("string"!=typeof r)throw new Error("`Mark.fromJS` requires a `type` string.");return new R({type:r,data:I.fromJS(s)})}static fromJSON(e){return i.a.deprecate("slate@0.35.0","fromJSON methods are deprecated, use fromJS instead"),R.fromJS(e)}static isMarkSet(e){return c.Set.isSet(e)&&e.every(e=>R.isMark(e))}get object(){return"mark"}get kind(){return i.a.deprecate("slate@0.32.0","The `kind` property of Slate objects has been renamed to `object`."),this.object}getComponent(e){return e.__getComponent(this)}toJS(){return{object:this.object,type:this.type,data:this.data.toJS()}}toJSON(){return i.a.deprecate("slate@0.35.0","toJSON methods are deprecated, use toJS instead"),this.toJS()}}T(R,"isMark",N.bind(null,"MARK")),R.prototype[w.MARK]=!0,n()(R.prototype,["getComponent"]);const M={};["deleteBackward","deleteCharBackward","deleteLineBackward","deleteWordBackward","deleteForward","deleteCharForward","deleteWordForward","deleteLineForward","setBlocks","setInlines","splitInline","unwrapBlock","unwrapInline","wrapBlock","wrapInline"].forEach(e=>{M[e]=function(t){const s=t.value.selection,r=`${e}AtRange`;for(var n=arguments.length,o=new Array(n>1?n-1:0),a=1;a<n;a++)o[a-1]=arguments[a];t[r](s,...o),e.match(/Backward$/)?t.collapseToStart():e.match(/Forward$/)&&t.collapseToEnd()}}),M.setBlock=function(){i.a.deprecate("slate@0.33.0","The `setBlock` method of Slate changes has been renamed to `setBlocks`."),M.setBlocks(...arguments)},M.setInline=function(){i.a.deprecate("slate@0.33.0","The `setInline` method of Slate changes has been renamed to `setInlines`."),M.setInlines(...arguments)},M.addMark=((e,t)=>{t=R.create(t);const s=e.value,r=s.document,n=s.selection;if(n.isExpanded)e.addMarkAtRange(n,t);else if(n.marks){const s=n.marks.add(t),r=n.set("marks",s);e.select(r)}else{const s=r.getActiveMarksAtRange(n).add(t),o=n.set("marks",s);e.select(o)}}),M.addMarks=((e,t)=>{t.forEach(t=>e.addMark(t))}),M.delete=(e=>{const t=e.value.selection;e.deleteAtRange(t),e.collapseToStart()}),M.insertBlock=((e,t)=>{t=P.create(t);const s=e.value.selection;e.insertBlockAtRange(s,t);const r=e.value.document.getNode(t.key);r&&e.collapseToEndOf(r)}),M.insertFragment=((e,t)=>{if(!t.nodes.size)return;let s=e.value,r=s,n=r.document,o=r.selection;const a=s,i=a.startText,c=a.endText,l=a.startInline,d=t.getLastText(),u=t.getClosestInline(d.key),h=t.nodes.first(),f=t.nodes.last(),y=n.getTexts().map(e=>e.key),g=!l||o.hasEdgeAtStartOf(i)||o.hasEdgeAtEndOf(c),m=t.hasBlocks(h.key)||t.hasBlocks(f.key);e.insertFragmentAtRange(o,t);const p=(n=(s=e.value).document).getTexts().filter(e=>!y.includes(e.key)),k=g?p.last():p.takeLast(2).first();k&&(u||m)?e.select(o.collapseToEndOf(k)):k?e.select(o.collapseToStartOf(k).move(d.text.length)):e.select(o.collapseToStart().move(d.text.length))}),M.insertInline=((e,t)=>{t=D.create(t);const s=e.value.selection;e.insertInlineAtRange(s,t);const r=e.value.document.getNode(t.key);r&&e.collapseToEndOf(r)}),M.insertText=((e,t,s)=>{const r=e.value,n=r.document,o=r.selection;s=s||o.marks||n.getInsertMarksAtRange(o),e.insertTextAtRange(o,t,s),o.marks&&n!=e.value.document&&e.select({marks:null})}),M.splitBlock=function(e,t){void 0===t&&(t=1);const s=e.value,r=s.selection,n=s.document,o=r.marks||n.getInsertMarksAtRange(r);e.splitBlockAtRange(r,t).collapseToEnd(),o&&0!==o.size&&e.select({marks:o})},M.removeMark=((e,t)=>{t=R.create(t);const s=e.value,r=s.document,n=s.selection;if(n.isExpanded)e.removeMarkAtRange(n,t);else if(n.marks){const s=n.marks.remove(t),r=n.set("marks",s);e.select(r)}else{const s=r.getActiveMarksAtRange(n).remove(t),o=n.set("marks",s);e.select(o)}}),M.replaceMark=((e,t,s)=>{e.removeMark(t),e.addMark(s)}),M.toggleMark=((e,t)=>{t=R.create(t),e.value.activeMarks.has(t)?e.removeMark(t):e.addMark(t)}),M.wrapText=function(e,t,s){void 0===s&&(s=t);const r=e.value.selection;e.wrapTextAtRange(r,t,s),r.isCollapsed&&e.moveStart(0-t.length),e.moveEnd(0-s.length),r.isForward!=e.value.selection.isForward&&e.flip()};const V={data:new c.Map,key:void 0,nodes:new c.List};class $ extends(Object(c.Record)(V)){static create(e){if(void 0===e&&(e={}),$.isDocument(e))return e;if((c.List.isList(e)||Array.isArray(e))&&(e={nodes:e}),a()(e))return $.fromJS(e);throw new Error(`\`Document.create\` only accepts objects, arrays, lists or documents, but you passed it: ${e}`)}static fromJS(e){if($.isDocument(e))return e;const t=e.data,s=void 0===t?{}:t,r=e.key,n=void 0===r?L():r,o=e.nodes,a=void 0===o?[]:o;return new $({key:n,data:new c.Map(s),nodes:$.createChildren(a)})}static fromJSON(e){return i.a.deprecate("slate@0.35.0","fromJSON methods are deprecated, use fromJS instead"),$.fromJS(e)}get object(){return"document"}get kind(){return i.a.deprecate("slate@0.32.0","The `kind` property of Slate objects has been renamed to `object`."),this.object}get isEmpty(){return!this.nodes.some(e=>!e.isEmpty)}get text(){return this.getText()}toJS(e){void 0===e&&(e={});const t={object:this.object,data:this.data.toJS(),nodes:this.nodes.toArray().map(t=>t.toJS(e))};return e.preserveKeys&&(t.key=this.key),t}toJSON(e){return i.a.deprecate("slate@0.35.0","toJSON methods are deprecated, use toJS instead"),this.toJS(e)}}T($,"isDocument",N.bind(null,"DOCUMENT")),$.prototype[w.DOCUMENT]=!0;const U={anchorKey:null,anchorOffset:0,focusKey:null,focusOffset:0,isBackward:null,isFocused:!1,marks:null,isAtomic:!1};class H extends(Object(c.Record)(U)){static create(e){if(void 0===e&&(e={}),H.isRange(e))return e;if(a()(e))return H.fromJS(e);throw new Error(`\`Range.create\` only accepts objects or ranges, but you passed it: ${e}`)}static createList(e){if(void 0===e&&(e=[]),c.List.isList(e)||Array.isArray(e)){return new c.List(e.map(H.create))}throw new Error(`\`Range.createList\` only accepts arrays or lists, but you passed it: ${e}`)}static createProperties(e){if(void 0===e&&(e={}),H.isRange(e))return{anchorKey:e.anchorKey,anchorOffset:e.anchorOffset,focusKey:e.focusKey,focusOffset:e.focusOffset,isBackward:e.isBackward,isFocused:e.isFocused,marks:e.marks,isAtomic:e.isAtomic};if(a()(e)){const t={};return"anchorKey"in e&&(t.anchorKey=e.anchorKey),"anchorOffset"in e&&(t.anchorOffset=e.anchorOffset),"anchorPath"in e&&(t.anchorPath=e.anchorPath),"focusKey"in e&&(t.focusKey=e.focusKey),"focusOffset"in e&&(t.focusOffset=e.focusOffset),"focusPath"in e&&(t.focusPath=e.focusPath),"isBackward"in e&&(t.isBackward=e.isBackward),"isFocused"in e&&(t.isFocused=e.isFocused),"marks"in e&&(t.marks=null==e.marks?null:R.createSet(e.marks)),"isAtomic"in e&&(t.isAtomic=e.isAtomic),t}throw new Error(`\`Range.createProperties\` only accepts objects or ranges, but you passed it: ${e}`)}static fromJS(e){const t=e.anchorKey,s=void 0===t?null:t,r=e.anchorOffset,n=void 0===r?0:r,o=e.focusKey,a=void 0===o?null:o,i=e.focusOffset,c=void 0===i?0:i,l=e.isBackward,d=void 0===l?null:l,u=e.isFocused,h=void 0!==u&&u,f=e.marks,y=void 0===f?null:f,g=e.isAtomic,m=void 0!==g&&g;return new H({anchorKey:s,anchorOffset:n,focusKey:a,focusOffset:c,isBackward:d,isFocused:h,marks:null==y?null:R.createSet(y),isAtomic:m})}static fromJSON(e){return i.a.deprecate("slate@0.35.0","fromJSON methods are deprecated, use fromJS instead"),H.fromJS(e)}static isRange(e){return!(!e||!e[w.RANGE])}get object(){return"range"}get kind(){return i.a.deprecate("slate@0.32.0","The `kind` property of Slate objects has been renamed to `object`."),this.object}get isBlurred(){return!this.isFocused}get isCollapsed(){return this.anchorKey==this.focusKey&&this.anchorOffset==this.focusOffset}get isExpanded(){return!this.isCollapsed}get isForward(){return null==this.isBackward?null:!this.isBackward}get isSet(){return null!=this.anchorKey&&null!=this.focusKey}get isUnset(){return!this.isSet}get startKey(){return this.isBackward?this.focusKey:this.anchorKey}get startOffset(){return this.isBackward?this.focusOffset:this.anchorOffset}get endKey(){return this.isBackward?this.anchorKey:this.focusKey}get endOffset(){return this.isBackward?this.anchorOffset:this.focusOffset}hasAnchorAtStartOf(e){if(0!=this.anchorOffset)return!1;const t=W(e);return this.anchorKey==t.key}hasAnchorAtEndOf(e){const t=q(e);return this.anchorKey==t.key&&this.anchorOffset==t.text.length}hasAnchorBetween(e,t,s){return this.anchorOffset<=s&&t<=this.anchorOffset&&this.hasAnchorIn(e)}hasAnchorIn(e){return"text"==e.object?e.key==this.anchorKey:null!=this.anchorKey&&e.hasDescendant(this.anchorKey)}hasFocusAtEndOf(e){const t=q(e);return this.focusKey==t.key&&this.focusOffset==t.text.length}hasFocusAtStartOf(e){if(0!=this.focusOffset)return!1;const t=W(e);return this.focusKey==t.key}hasFocusBetween(e,t,s){return t<=this.focusOffset&&this.focusOffset<=s&&this.hasFocusIn(e)}hasFocusIn(e){return"text"==e.object?e.key==this.focusKey:null!=this.focusKey&&e.hasDescendant(this.focusKey)}isAtStartOf(e){return this.isCollapsed&&this.hasAnchorAtStartOf(e)}isAtEndOf(e){return this.isCollapsed&&this.hasAnchorAtEndOf(e)}focus(){return this.merge({isFocused:!0})}blur(){return this.merge({isFocused:!1})}deselect(){return this.merge({anchorKey:null,anchorOffset:0,focusKey:null,focusOffset:0,isFocused:!1,isBackward:!1})}flip(){return this.merge({anchorKey:this.focusKey,anchorOffset:this.focusOffset,focusKey:this.anchorKey,focusOffset:this.anchorOffset,isBackward:null==this.isBackward?null:!this.isBackward})}moveAnchor(e){void 0===e&&(e=1);const t=this.anchorKey,s=this.focusKey,r=this.focusOffset,n=this.isBackward,o=this.anchorOffset+e;return this.merge({anchorOffset:o,isBackward:t==s?o>r:n})}moveFocus(e){void 0===e&&(e=1);const t=this.anchorKey,s=this.anchorOffset,r=this.focusKey,n=this.isBackward,o=this.focusOffset+e;return this.merge({focusOffset:o,isBackward:r==t?s>o:n})}moveAnchorTo(e,t){const s=this.anchorKey,r=this.focusKey,n=this.focusOffset,o=this.isBackward;return this.merge({anchorKey:e,anchorOffset:t,isBackward:e==r?t>n:e==s?o:null})}moveFocusTo(e,t){const s=this.focusKey,r=this.anchorKey,n=this.anchorOffset,o=this.isBackward;return this.merge({focusKey:e,focusOffset:t,isBackward:e==r?n>t:e==s?o:null})}moveAnchorOffsetTo(e){return this.merge({anchorOffset:e,isBackward:this.anchorKey==this.focusKey?e>this.focusOffset:this.isBackward})}moveFocusOffsetTo(e){return this.merge({focusOffset:e,isBackward:this.anchorKey==this.focusKey?this.anchorOffset>e:this.isBackward})}moveOffsetsTo(e,t){return void 0===t&&(t=e),this.moveAnchorOffsetTo(e).moveFocusOffsetTo(t)}moveToAnchor(){return this.moveFocusTo(this.anchorKey,this.anchorOffset)}moveToFocus(){return this.moveAnchorTo(this.focusKey,this.focusOffset)}moveAnchorToStartOf(e){return e=W(e),this.moveAnchorTo(e.key,0)}moveAnchorToEndOf(e){return e=q(e),this.moveAnchorTo(e.key,e.text.length)}moveFocusToStartOf(e){return e=W(e),this.moveFocusTo(e.key,0)}moveFocusToEndOf(e){return e=q(e),this.moveFocusTo(e.key,e.text.length)}moveToRangeOf(e,t){return void 0===t&&(t=e),(this.isBackward?this.flip():this).moveAnchorToStartOf(e).moveFocusToEndOf(t)}normalize(e){const t=this;let s=t.anchorKey,r=t.anchorOffset,n=t.focusKey,o=t.focusOffset,a=t.isBackward;const c=typeof r,l=typeof o;if("number"==c&&"number"==l||i.a.warn(`The range offsets should be numbers, but they were of type "${c}" and "${l}".`),null==s||null==n)return t.merge({anchorKey:null,anchorOffset:0,focusKey:null,focusOffset:0,isBackward:!1});let d=e.getDescendant(s),u=e.getDescendant(n);if(!d||!u){i.a.warn("The range was invalid and was reset. The range in question was:",t);const s=e.getFirstText();return t.merge({anchorKey:s?s.key:null,anchorOffset:0,focusKey:s?s.key:null,focusOffset:0,isBackward:!1})}if("text"!=d.object){i.a.warn("The range anchor was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:",d);const e=d.getTextAtOffset(r);r-=d.getOffset(e.key),d=e}if("text"!=u.object){i.a.warn("The range focus was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:",u);const e=u.getTextAtOffset(o);o-=u.getOffset(e.key),u=e}null==a&&(a=d.key===u.key?r>o:!e.areDescendantsSorted(d.key,u.key));const h=e.getDescendant(s),f=e.getDescendant(n);return r=Math.min(Math.max(0,r),h.text.length),o=Math.min(Math.max(0,o),f.text.length),t.merge({anchorKey:d.key,anchorOffset:r,focusKey:u.key,focusOffset:o,isBackward:a})}toJS(){return{object:this.object,anchorKey:this.anchorKey,anchorOffset:this.anchorOffset,focusKey:this.focusKey,focusOffset:this.focusOffset,isBackward:this.isBackward,isFocused:this.isFocused,marks:null==this.marks?null:this.marks.toArray().map(e=>e.toJS()),isAtomic:this.isAtomic}}toJSON(){return i.a.deprecate("slate@0.35.0","toJSON methods are deprecated, use toJS instead"),this.toJS()}}H.prototype[w.RANGE]=!0;[["move",""],["move","To"],["move","ToStartOf"],["move","ToEndOf"]].forEach(e=>{let t=e[0],s=e[1];H.prototype[`${t}${s}`]=function(){return this[`${t}Anchor${s}`](...arguments)[`${t}Focus${s}`](...arguments)}});[["has","AtStartOf",!0],["has","AtEndOf",!0],["has","Between",!0],["has","In",!0],["collapseTo",""],["move",""],["moveTo",""],["move","To"],["move","OffsetTo"]].forEach(e=>{let t=e[0],s=e[1],r=e[2];const n=`${t}Anchor${s}`,o=`${t}Focus${s}`;H.prototype[`${t}Start${s}`]=function(){return this.isBackward?this[o](...arguments):this[n](...arguments)},H.prototype[`${t}End${s}`]=function(){return this.isBackward?this[n](...arguments):this[o](...arguments)},r&&(H.prototype[`${t}Edge${s}`]=function(){return this[n](...arguments)||this[o](...arguments)})});function W(e){return"text"==e.object?e:e.getFirstText()}function q(e){return"text"==e.object?e:e.getLastText()}[["collapseTo","moveTo"],["collapseToAnchor","moveToAnchor"],["collapseToFocus","moveToFocus"],["collapseToStart","moveToStart"],["collapseToEnd","moveToEnd"],["collapseToStartOf","moveToStartOf"],["collapseToEndOf","moveToEndOf"],["extend","moveFocus"],["extendTo","moveFocusTo"],["extendToStartOf","moveFocusToStartOf"],["extendToEndOf","moveFocusToEndOf"]].forEach(e=>{let t=e[0],s=e[1];H.prototype[t]=function(){return this[s](...arguments)}});const G={marks:new c.Set,text:""};class Y extends(Object(c.Record)(G)){static create(e){if(void 0===e&&(e={}),Y.isCharacter(e))return e;if("string"==typeof e&&(e={text:e}),a()(e))return Y.fromJS(e);throw new Error(`\`Character.create\` only accepts objects, strings or characters, but you passed it: ${e}`)}static createList(e){if(void 0===e&&(e=[]),"string"==typeof e&&(e=e.split("")),c.List.isList(e)||Array.isArray(e)){return new c.List(e.map(Y.create))}throw new Error(`\`Block.createList\` only accepts strings, arrays or lists, but you passed it: ${e}`)}static fromJS(e){const t=e.text,s=e.marks,r=void 0===s?[]:s;if("string"!=typeof t)throw new Error("`Character.fromJS` requires a block `text` string.");return new Y({text:t,marks:new c.Set(r)})}static fromJSON(e){return i.a.deprecate("slate@0.35.0","fromJSON methods are deprecated, use fromJS instead"),Y.fromJS(e)}static isCharacterList(e){return c.List.isList(e)&&e.every(e=>Y.isCharacter(e))}get object(){return"character"}get kind(){return i.a.deprecate("slate@0.32.0","The `kind` property of Slate objects has been renamed to `object`."),this.object}toJS(){return{object:this.object,text:this.text,marks:this.marks.toArray().map(e=>e.toJS())}}toJSON(){return i.a.deprecate("slate@0.35.0","toJSON methods are deprecated, use toJS instead"),this.toJS()}}T(Y,"isCharacter",N.bind(null,"CHARACTER")),Y.prototype[w.CHARACTER]=!0;const X={marks:Object(c.Set)(),text:""};class Q extends(Object(c.Record)(X)){static create(e){if(void 0===e&&(e={}),Q.isLeaf(e))return e;if("string"==typeof e&&(e={text:e}),a()(e))return Q.fromJS(e);throw new Error(`\`Leaf.create\` only accepts objects, strings or leaves, but you passed it: ${e}`)}static createLeaves(e){if(e.size<=1)return e;let t=!1;const s=Object(c.List)().withMutations(s=>{e.findLast((e,r)=>{const n=s.first();if(n){if(n.marks.equals(e.marks))return t=!0,void s.set(0,n.set("text",`${e.text}${n.text}`));if(""===n.text)return t=!0,void s.set(0,e);if(""===e.text)return void(t=!0)}s.unshift(e)})});return t?s:e}static splitLeaves(e,t){if(t<0)return[Object(c.List)(),e];if(0===e.size)return[Object(c.List)(),Object(c.List)()];let s,r,n=0,o=-1;return e.find(e=>{o++;const a=n,i=e.text;if((n+=i.length)<t)return!1;if(a>t)return!1;const c=t-a;return s=e.set("text",i.slice(0,c)),r=e.set("text",i.slice(c)),!0}),s?""===s.text?0===o?[c.List.of(s),e]:[e.take(o),e.skip(o)]:""===r.text?o===e.size-1?[e,c.List.of(r)]:[e.take(o+1),e.skip(o+1)]:[e.take(o).push(s),e.skip(o+1).unshift(r)]:[e,Object(c.List)()]}static createList(e){if(void 0===e&&(e=[]),c.List.isList(e)||Array.isArray(e)){return new c.List(e.map(Q.create))}throw new Error(`\`Leaf.createList\` only accepts arrays or lists, but you passed it: ${e}`)}static fromJS(e){const t=e.text,s=void 0===t?"":t,r=e.marks,n=void 0===r?[]:r;return new Q({text:s,marks:Object(c.Set)(n.map(R.fromJS))})}static fromJSON(e){return i.a.deprecate("slate@0.35.0","fromJSON methods are deprecated, use fromJS instead"),Q.fromJS(e)}static isLeafList(e){return c.List.isList(e)&&e.every(e=>Q.isLeaf(e))}get object(){return"leaf"}get kind(){return i.a.deprecate("slate@0.32.0","The `kind` property of Slate objects has been renamed to `object`."),this.object}getCharacters(){i.a.deprecate("slate@0.34.0","The `characters` property of Slate objects is deprecated");const e=this.marks;return Y.createList(this.text.split("").map(t=>Y.create({text:t,marks:e})))}updateMark(e,t){const s=this.marks;if(t.equals(e))return this;if(!s.has(e))return this;const r=s.withMutations(s=>{s.remove(e).add(t)});return this.set("marks",r)}addMarks(e){const t=this.marks;return this.set("marks",t.union(e))}removeMark(e){const t=this.marks;return this.set("marks",t.remove(e))}toJS(){return{object:this.object,text:this.text,marks:this.marks.toArray().map(e=>e.toJS())}}toJSON(){return i.a.deprecate("slate@0.35.0","toJSON methods are deprecated, use toJS instead"),this.toJS()}}T(Q,"isLeaf",N.bind(null,"LEAF")),Q.prototype[w.LEAF]=!0;const Z={leaves:Object(c.List)(),key:void 0};class ee extends(Object(c.Record)(Z)){static create(e){if(void 0===e&&(e=""),ee.isText(e))return e;if("string"==typeof e&&(e={leaves:[{text:e}]}),a()(e)){if(e.text){const t=e,s=t.text,r=t.marks;e={key:t.key,leaves:[{text:s,marks:r}]}}return ee.fromJS(e)}throw new Error(`\`Text.create\` only accepts objects, arrays, strings or texts, but you passed it: ${e}`)}static createList(e){if(void 0===e&&(e=[]),c.List.isList(e)||Array.isArray(e)){return new c.List(e.map(ee.create))}throw new Error(`\`Text.createList\` only accepts arrays or lists, but you passed it: ${e}`)}static fromJS(e){if(ee.isText(e))return e;const t=e.key,s=void 0===t?L():t;let r=e.leaves,n=void 0===r?Object(c.List)():r;if(Array.isArray(n))n=Object(c.List)(n.map(e=>Q.create(e)));else{if(!c.List.isList(n))throw new Error("leaves must be either Array or Immutable.List");n=n.map(e=>Q.create(e))}return new ee({leaves:Q.createLeaves(n),key:s})}static fromJSON(e){return i.a.deprecate("slate@0.35.0","fromJSON methods are deprecated, use fromJS instead"),ee.fromJS(e)}static isTextList(e){return c.List.isList(e)&&e.every(e=>ee.isText(e))}get object(){return"text"}get kind(){return i.a.deprecate("slate@0.32.0","The `kind` property of Slate objects has been renamed to `object`."),this.object}get isEmpty(){return""==this.text}get text(){return this.getString()}getString(){return this.leaves.reduce((e,t)=>e+t.text,"")}get characters(){return this.leaves.flatMap(e=>e.getCharacters())}searchLeafAtOffset(e){let t=0,s=0,r=-1;return{leaf:this.leaves.find(n=>(r++,(t=(s=t)+n.text.length)>=e)),endOffset:t,index:r,startOffset:s}}addMark(e,t,s){const r=c.Set.of(s);return this.addMarks(e,t,r)}addMarks(e,t,s){if(""===this.text&&0===t&&0===e){const e=this.leaves.first();if(!e)return this.set("leaves",c.List.of(Q.fromJS({text:"",marks:s})));const t=e.addMarks(s);return t===e?this:this.set("leaves",c.List.of(t))}if(""===this.text)return this;if(0===t)return this;if(e>=this.text.length)return this;const r=Q.splitLeaves(this.leaves,e),n=r[0],o=r[1],a=Q.splitLeaves(o,t),i=a[0],l=a[1],d=n.concat(i.map(e=>e.addMarks(s)),l);return this.setLeaves(d)}getDecorations(e){return e.__getDecorations(this)}getLeaves(e){void 0===e&&(e=[]);let t=this.leaves;if(0===t.size)return c.List.of(Q.create({}));if(!e||0===e.length)return t;if(0===this.text.length)return t;const s=this.key;return e.forEach(e=>{const r=e.startKey,n=e.endKey,o=e.startOffset,a=e.endOffset,i=e.marks,c=r==s,l=n==s;if(c&&l){const e=c?o:0,s=l?a-e:this.text.length-e;if(s<1)return;if(e>=this.text.length)return;if(0!==e||s<this.text.length){const r=Q.splitLeaves(t,e),n=r[0],o=r[1],a=Q.splitLeaves(o,s),c=a[0],l=a[1];return void(t=n.concat(c.map(e=>e.addMarks(i)),l))}}t=t.map(e=>e.addMarks(i))}),t===this.leaves?t:Q.createLeaves(t)}getActiveMarksBetweenOffsets(e,t){if(e<=0&&t>=this.text.length)return this.getActiveMarks();if(e>=t)return Object(c.Set)();if(""===this.text)return this.getActiveMarks();let s=null,r=0;return this.leaves.forEach(n=>{const o=r;if(!((r=o+n.text.length)<=e)){if(o>=t)return!1;if(s)return(s=s.intersect(n.marks))&&s.size,!1;s=n.marks}}),s||Object(c.Set)()}getActiveMarks(){if(0===this.leaves.size)return Object(c.Set)();const e=this.leaves.first().marks;return 0===e.size?e:e.withMutations(e=>{this.leaves.forEach(t=>{if(e.intersect(t.marks),0===e.size)return!1})})}getMarksBetweenOffsets(e,t){if(e<=0&&t>=this.text.length)return this.getMarks();if(e>=t)return Object(c.Set)();if(""===this.text)return this.getActiveMarks();let s=null,r=0;return this.leaves.forEach(n=>{const o=r;if(!((r=o+n.text.length)<=e))return!(o>=t)&&void(s=s?s.union(n.marks):n.marks)}),s||Object(c.Set)()}getMarks(){const e=this.getMarksAsArray();return new c.OrderedSet(e)}getMarksAsArray(){if(0===this.leaves.size)return[];const e=this.leaves.first().marks;if(1===this.leaves.size)return e.toArray();const t=[];return this.leaves.forEach(e=>{t.push(e.marks.toArray())}),Array.prototype.concat.apply(e.toArray(),t)}getMarksAtIndex(e){const t=this.searchLeafAtOffset(e).leaf;return t?t.marks:Object(c.Set)()}getNode(e){return this.key==e?this:null}hasNode(e){return!!this.getNode(e)}insertText(e,t,s){if(""===this.text)return this.set("leaves",c.List.of(Q.create({text:t,marks:s})));if(0===t.length)return this;s||(s=Object(c.Set)());const r=this.searchLeafAtOffset(e),n=r.startOffset,o=r.leaf,a=r.index,i=e-n,l=o.text.slice(0,i),d=o.text.slice(i),u=this.leaves;if(o.marks.equals(s))return this.set("leaves",u.set(a,o.set("text",l+t+d)));const h=u.splice(a,1,o.set("text",l),Q.create({text:t,marks:s}),o.set("text",d));return this.setLeaves(h)}regenerateKey(){const e=L();return this.set("key",e)}removeMark(e,t,s){if(""===this.text&&0===e&&0===t){const e=this.leaves.first();if(!e)return this;const t=e.removeMark(s);return t===e?this:this.set("leaves",c.List.of(t))}if(t<=0)return this;if(e>=this.text.length)return this;const r=Q.splitLeaves(this.leaves,e),n=r[0],o=r[1],a=Q.splitLeaves(o,t),i=a[0],l=a[1],d=n.concat(i.map(e=>e.removeMark(s)),l);return this.setLeaves(d)}removeText(e,t){if(t<=0)return this;if(e>=this.text.length)return this;if(1===t){const s=this.searchLeafAtOffset(e+1),r=s.leaf,n=s.index,o=e-s.startOffset;if(r){if(1===r.text.length){const e=this.leaves.remove(n);return this.setLeaves(e)}const e=r.text.slice(0,o)+r.text.slice(o+t);if(e.length>0)return this.set("leaves",this.leaves.set(n,r.set("text",e)))}}const s=Q.splitLeaves(this.leaves,e),r=s[0],n=s[1],o=Q.splitLeaves(n,t)[1],a=Q.createLeaves(r.concat(o));if(1===a.size){const e=a.first();if(""===e.text)return this.set("leaves",c.List.of(e.set("marks",this.getActiveMarks())))}return this.set("leaves",a)}toJS(e){void 0===e&&(e={});const t={object:this.object,leaves:this.getLeaves().toArray().map(e=>e.toJS())};return e.preserveKeys&&(t.key=this.key),t}toJSON(e){return i.a.deprecate("slate@0.35.0","toJSON methods are deprecated, use toJS instead"),this.toJS(e)}updateMark(e,t,s,r){const n=s.merge(r);if(""===this.text&&0===t&&0===e){const e=this.leaves.first();if(!e)return this;const t=e.updateMark(s,n);return t===e?this:this.set("leaves",c.List.of(t))}if(t<=0)return this;if(e>=this.text.length)return this;const o=Q.splitLeaves(this.leaves,e),a=o[0],i=o[1],l=Q.splitLeaves(i,t),d=l[0],u=l[1],h=a.concat(d.map(e=>e.updateMark(s,n)),u);return this.setLeaves(h)}splitText(e){const t=Q.splitLeaves(this.leaves,e);return[this.set("leaves",t[0]),this.set("leaves",t[1]).regenerateKey()]}mergeText(e){const t=this.leaves.concat(e.leaves);return this.setLeaves(t)}validate(e){return e.validateNode(this)}getFirstInvalidDescendant(e){return this.validate(e)?this:null}setLeaves(e){const t=Q.createLeaves(e);if(1===t.size){const e=t.first();if((!e.marks||0===e.marks.size)&&""===e.text)return this.set("leaves",Object(c.List)())}return this.set("leaves",Q.createLeaves(e))}}T(ee,"isText",N.bind(null,"TEXT")),ee.prototype[w.TEXT]=!0,n()(ee.prototype,["getDecorations","getActiveMarks","getMarks","getMarksAsArray","validate","getString"]);class te{static create(e){if(void 0===e&&(e={}),te.isNode(e))return e;if(a()(e)){let t=e.object;switch(!t&&e.kind&&(i.a.deprecate("slate@0.32.0","The `kind` property of Slate objects has been renamed to `object`."),t=e.kind),t){case"block":return P.create(e);case"document":return $.create(e);case"inline":return D.create(e);case"text":return ee.create(e);default:throw new Error("`Node.create` requires a `object` string.")}}throw new Error(`\`Node.create\` only accepts objects or nodes but you passed it: ${e}`)}static createList(e){if(void 0===e&&(e=[]),c.List.isList(e)||Array.isArray(e)){return Object(c.List)(e.map(te.create))}throw new Error(`\`Node.createList\` only accepts lists or arrays, but you passed it: ${e}`)}static createProperties(e){if(void 0===e&&(e={}),P.isBlock(e)||D.isInline(e))return{data:e.data,isVoid:e.isVoid,type:e.type};if("string"==typeof e)return{type:e};if(a()(e)){const t={};return"type"in e&&(t.type=e.type),"data"in e&&(t.data=I.create(e.data)),"isVoid"in e&&(t.isVoid=e.isVoid),t}throw new Error(`\`Node.createProperties\` only accepts objects, strings, blocks or inlines, but you passed it: ${e}`)}static fromJSON(e){let t=e.object;switch(!t&&e.kind&&(i.a.deprecate("slate@0.32.0","The `kind` property of Slate objects has been renamed to `object`."),t=e.kind),t){case"block":return P.fromJS(e);case"document":return $.fromJS(e);case"inline":return D.fromJS(e);case"text":return ee.fromJS(e);default:throw new Error(`\`Node.fromJS\` requires an \`object\` of either 'block', 'document', 'inline' or 'text', but you passed: ${e}`)}}static isNode(e){return!!["BLOCK","DOCUMENT","INLINE","TEXT"].find(t=>N(t,e))}static isNodeList(e){return c.List.isList(e)&&e.every(e=>te.isNode(e))}areDescendantsSorted(e,t){e=se(e),t=se(t);const s=this.getKeysAsArray(),r=s.indexOf(e),n=s.indexOf(t);return-1==r||-1==n?null:r<n}assertChild(e){const t=this.getChild(e);if(!t)throw e=se(e),new Error(`Could not find a child node with key "${e}".`);return t}assertDescendant(e){const t=this.getDescendant(e);if(!t)throw e=se(e),new Error(`Could not find a descendant node with key "${e}".`);return t}assertNode(e){const t=this.getNode(e);if(!t)throw e=se(e),new Error(`Could not find a node with key "${e}".`);return t}assertPath(e){const t=this.getDescendantAtPath(e);if(!t)throw new Error(`Could not find a descendant at path "${e}".`);return t}filterDescendants(e){const t=[];return this.forEachDescendant((s,r,n)=>{e(s,r,n)&&t.push(s)}),Object(c.List)(t)}findDescendant(e){let t=null;return this.forEachDescendant((s,r,n)=>{if(e(s,r,n))return t=s,!1}),t}forEachDescendant(e){let t;return this.nodes.forEach((s,r,n)=>!1===e(s,r,n)?(t=!1,!1):"text"!=s.object?t=s.forEachDescendant(e):void 0),t}getAncestors(e){if((e=se(e))==this.key)return Object(c.List)();if(this.hasChild(e))return Object(c.List)([this]);let t;return this.nodes.find(s=>"text"!=s.object&&(t=s.getAncestors(e))),t?t.unshift(this):null}getBlocks(){const e=this.getBlocksAsArray();return new c.List(e)}getBlocksAsArray(){return this.nodes.reduce((e,t)=>"block"!=t.object?e:t.isLeafBlock()?(e.push(t),e):e.concat(t.getBlocksAsArray()),[])}getBlocksAtRange(e){const t=this.getBlocksAtRangeAsArray(e);return new c.List(new c.OrderedSet(t))}getBlocksAtRangeAsArray(e){if((e=e.normalize(this)).isUnset)return[];const t=e,s=t.startKey,r=t.endKey,n=this.getClosestBlock(s);if(s==r)return[n];const o=this.getClosestBlock(r),a=this.getBlocksAsArray(),i=a.indexOf(n),c=a.indexOf(o);return a.slice(i,c+1)}getBlocksByType(e){const t=this.getBlocksByTypeAsArray(e);return new c.List(t)}getBlocksByTypeAsArray(e){return this.nodes.reduce((t,s)=>"block"!=s.object?t:s.isLeafBlock()&&s.type==e?(t.push(s),t):t.concat(s.getBlocksByTypeAsArray(e)),[])}getCharacters(){return this.getTexts().flatMap(e=>e.characters)}getCharactersAtRange(e){if((e=e.normalize(this)).isUnset)return Object(c.List)();const t=e,s=t.startKey,r=t.endKey,n=t.startOffset,o=t.endOffset;if(s===r){return this.getDescendant(r).characters.slice(n,o)}return this.getTextsAtRange(e).flatMap(e=>e.key===s?e.characters.slice(n):e.key===r?e.characters.slice(0,o):e.characters)}getChild(e){return e=se(e),this.nodes.find(t=>t.key==e)}getClosest(e,t){e=se(e);const s=this.getAncestors(e);if(!s)throw new Error(`Could not find a descendant node with key "${e}".`);return s.rest().findLast(t)}getClosestBlock(e){return this.getClosest(e,e=>"block"==e.object)}getClosestInline(e){return this.getClosest(e,e=>"inline"==e.object)}getClosestVoid(e){return this.getClosest(e,e=>e.isVoid)}getCommonAncestor(e,t){if(e=se(e),t=se(t),e==this.key)return this;if(t==this.key)return this;this.assertDescendant(e),this.assertDescendant(t);let s=new c.List,r=this.getParent(e),n=this.getParent(t);for(;r;)s=s.push(r),r=this.getParent(r.key);for(;n;){if(s.includes(n))return n;n=this.getParent(n.key)}}getDecorations(e){const t=e.find("decorateNode",this);return H.createList(t||[])}getDepth(e,t){return void 0===t&&(t=1),this.assertDescendant(e),this.hasChild(e)?t:this.getFurthestAncestor(e).getDepth(e,t+1)}getDescendant(e){e=se(e);let t=null;const s=this.nodes.find(s=>s.key===e?s:"text"!==s.object&&(t=s.getDescendant(e)));return t||s}getDescendantAtPath(e){let t=this;for(const s of e){if(!t)return;if(!t.nodes)return;t=t.nodes.get(s)}return t}getFirstText(){let e=null;const t=this.nodes.find(t=>"text"==t.object||(e=t.getFirstText()));return e||t}getFragmentAtRange(e){if((e=e.normalize(this)).isUnset)return $.create();let t=this;const s=e,r=s.startKey,n=s.startOffset,o=s.endKey,a=s.endOffset,i=t.assertDescendant(r),c=t.assertDescendant(o);let l,d,u=i;for(;d=t.getParent(u.key);){const e=d.nodes.indexOf(u),s="text"==u.object?n:u.nodes.indexOf(l);d=d.splitNode(e,s),t=t.updateNode(d),l=d.nodes.get(e+1),u=d}for(u=r==o?t.getNextText(r):c;d=t.getParent(u.key);){const e=d.nodes.indexOf(u),s="text"==u.object?r==o?a-n:a:u.nodes.indexOf(l);d=d.splitNode(e,s),t=t.updateNode(d),l=d.nodes.get(e+1),u=d}const h=t.getNextSibling(t.getFurthestAncestor(r).key),f=r==o?t.getNextSibling(t.getNextSibling(t.getFurthestAncestor(o).key).key):t.getNextSibling(t.getFurthestAncestor(o).key),y=t.nodes.indexOf(h),g=t.nodes.indexOf(f),m=t.nodes.slice(y,g);return $.create({nodes:m})}getFurthest(e,t){const s=this.getAncestors(e);if(!s)throw e=se(e),new Error(`Could not find a descendant node with key "${e}".`);return s.rest().find(t)}getFurthestBlock(e){return this.getFurthest(e,e=>"block"==e.object)}getFurthestInline(e){return this.getFurthest(e,e=>"inline"==e.object)}getFurthestAncestor(e){return e=se(e),this.nodes.find(t=>t.key==e||"text"!=t.object&&t.hasDescendant(e))}getFurthestOnlyChildAncestor(e){const t=this.getAncestors(e);if(!t)throw e=se(e),new Error(`Could not find a descendant node with key "${e}".`);const s=t.shift().reverse().takeUntil(e=>e.nodes.size>1).last();return s||null}getInlines(){const e=this.getInlinesAsArray();return new c.List(e)}getInlinesAsArray(){let e=[];return this.nodes.forEach(t=>{"text"!=t.object&&(t.isLeafInline()?e.push(t):e=e.concat(t.getInlinesAsArray()))}),e}getInlinesAtRange(e){const t=this.getInlinesAtRangeAsArray(e);return new c.List(new c.OrderedSet(t))}getInlinesAtRangeAsArray(e){return(e=e.normalize(this)).isUnset?[]:this.getTextsAtRangeAsArray(e).map(e=>this.getClosestInline(e.key)).filter(e=>e)}getInlinesByType(e){const t=this.getInlinesByTypeAsArray(e);return new c.List(t)}getInlinesByTypeAsArray(e){return this.nodes.reduce((t,s)=>"text"==s.object?t:s.isLeafInline()&&s.type==e?(t.push(s),t):t.concat(s.getInlinesByTypeAsArray(e)),[])}getKeysAsArray(){const e=[];return this.forEachDescendant(t=>{e.push(t.key)}),e}getKeys(){const e=this.getKeysAsArray();return new c.Set(e)}getLastText(){let e=null;const t=this.nodes.findLast(t=>"text"==t.object||(e=t.getLastText()));return e||t}getMarks(){const e=this.getMarksAsArray();return new c.Set(e)}getOrderedMarks(){const e=this.getMarksAsArray();return new c.OrderedSet(e)}getMarksAsArray(){const e=[];return this.nodes.forEach(t=>{e.push(t.getMarksAsArray())}),Array.prototype.concat.apply([],e)}getMarksAtRange(e){return new c.Set(this.getOrderedMarksAtRange(e))}getInsertMarksAtRange(e){if((e=e.normalize(this)).isUnset)return Object(c.Set)();if(e.isCollapsed)return this.getMarksAtPosition(e.startKey,e.startOffset);const t=e,s=t.startKey,r=t.startOffset;return this.getDescendant(s).getMarksAtIndex(r+1)}getOrderedMarksAtRange(e){if((e=e.normalize(this)).isUnset)return Object(c.OrderedSet)();if(e.isCollapsed)return this.getMarksAtPosition(e.startKey,e.startOffset);const t=e,s=t.startKey,r=t.startOffset,n=t.endKey,o=t.endOffset;return this.getOrderedMarksBetweenPositions(s,r,n,o)}getOrderedMarksBetweenPositions(e,t,s,r){if(e===s){return this.getDescendant(e).getMarksBetweenOffsets(t,r)}const n=this.getTextsBetweenPositionsAsArray(e,s);return Object(c.OrderedSet)().withMutations(o=>{n.forEach(n=>{n.key===e?o.union(n.getMarksBetweenOffsets(t,n.text.length)):n.key===s?o.union(n.getMarksBetweenOffsets(0,r)):o.union(n.getMarks())})})}getActiveMarksAtRange(e){if((e=e.normalize(this)).isUnset)return Object(c.Set)();if(e.isCollapsed){const t=e,s=t.startKey,r=t.startOffset;return this.getMarksAtPosition(s,r).toSet()}let t=e,s=t.startKey,r=t.endKey,n=t.startOffset,o=t.endOffset,a=this.getDescendant(s);if(s!==r){for(;s!==r&&0===o;){const e=this.getPreviousText(r);r=e.key,o=e.text.length}for(;s!==r&&n===a.text.length;)s=(a=this.getNextText(s)).key,n=0}if(s===r)return a.getActiveMarksBetweenOffsets(n,o);const i=a.getActiveMarksBetweenOffsets(n,a.text.length);if(0===i.size)return Object(c.Set)();const l=this.getDescendant(r).getActiveMarksBetweenOffsets(0,o);let d=i.intersect(l);if(0===d.size)return d;let u=this.getNextText(s);for(;u.key!==r;){if(0!==u.text.length&&0===(d=d.intersect(u.getActiveMarks())).size)return Object(c.Set)();u=this.getNextText(u.key)}return d}getMarksAtPosition(e,t){const s=this.getDescendant(e).getMarksAtIndex(t);if(0!==t)return s;const r=this.getClosestBlock(e);if(""===r.text)return s;const n=this.getPreviousText(e);return n?r.hasDescendant(n.key)?n.getMarksAtIndex(n.text.length):s:Object(c.Set)()}getMarksByType(e){const t=this.getMarksByTypeAsArray(e);return new c.Set(t)}getOrderedMarksByType(e){const t=this.getMarksByTypeAsArray(e);return new c.OrderedSet(t)}getMarksByTypeAsArray(e){return this.nodes.reduce((t,s)=>"text"==s.object?t.concat(s.getMarksAsArray().filter(t=>t.type==e)):t.concat(s.getMarksByTypeAsArray(e)),[])}getNextBlock(e){const t=this.assertDescendant(e);let s;if("block"==t.object)s=t.getLastText();else{s=this.getClosestBlock(e).getLastText()}const r=this.getNextText(s.key);return r?this.getClosestBlock(r.key):null}getNextSibling(e){e=se(e);const t=this.getParent(e).nodes.skipUntil(t=>t.key==e);if(0==t.size)throw new Error(`Could not find a child node with key "${e}".`);return t.get(1)}getNextText(e){return e=se(e),this.getTexts().skipUntil(t=>t.key==e).get(1)}getNode(e){return e=se(e),this.key==e?this:this.getDescendant(e)}getNodeAtPath(e){return e.length?this.getDescendantAtPath(e):this}getOffset(e){this.assertDescendant(e);const t=this.getFurthestAncestor(e),s=this.nodes.takeUntil(e=>e==t).reduce((e,t)=>e+t.text.length,0);return this.hasChild(e)?s:s+t.getOffset(e)}getOffsetAtRange(e){if((e=e.normalize(this)).isUnset)throw new Error("The range cannot be unset to calculcate its offset.");if(e.isExpanded)throw new Error("The range must be collapsed to calculcate its offset.");const t=e,s=t.startKey,r=t.startOffset;return this.getOffset(s)+r}getParent(e){if(this.hasChild(e))return this;let t=null;return this.nodes.find(s=>"text"!=s.object&&(t=s.getParent(e))),t}getPath(e){let t=this.assertNode(e);const s=this.getAncestors(e),r=[];return s.reverse().forEach(e=>{const s=e.nodes.indexOf(t);r.unshift(s),t=e}),r}refindPath(e,t){const s=this.getDescendantAtPath(e);return s&&s.key===t?e:this.getPath(t)}refindNode(e,t){const s=this.getDescendantAtPath(e);return s&&s.key===t?s:this.getDescendant(t)}getPlaceholder(e){return e.__getPlaceholder(this)}getPreviousBlock(e){const t=this.assertDescendant(e);let s;if("block"==t.object)s=t.getFirstText();else{s=this.getClosestBlock(e).getFirstText()}const r=this.getPreviousText(s.key);return r?this.getClosestBlock(r.key):null}getPreviousSibling(e){e=se(e);const t=this.getParent(e),s=t.nodes.takeUntil(t=>t.key==e);if(s.size==t.nodes.size)throw new Error(`Could not find a child node with key "${e}".`);return s.last()}getPreviousText(e){return e=se(e),this.getTexts().takeUntil(t=>t.key==e).last()}getSelectionIndexes(e,t){void 0===t&&(t=!0);const s=e.startKey,r=e.endKey;if(!t)return null;if(e.isUnset)return null;if(s==r){const e=this.getFurthestAncestor(s),t=e?this.nodes.indexOf(e):null;return{start:t,end:t+1}}let n=null,o=null;return this.nodes.forEach((e,t)=>("text"==e.object?(null==n&&e.key==s&&(n=t),null==o&&e.key==r&&(o=t+1)):(null==n&&e.hasDescendant(s)&&(n=t),null==o&&e.hasDescendant(r)&&(o=t+1)),null==n||null==o)),t&&null==n&&(n=0),t&&null==o&&(o=this.nodes.size),null==n?null:{start:n,end:o}}getText(){return this.nodes.reduce((e,t)=>e+t.text,"")}getTextAtOffset(e){if(0==e)return this.getFirstText();if(e==this.text.length)return this.getLastText();if(e<0||e>this.text.length)return null;let t=0;return this.getTexts().find((s,r,n)=>(t+=s.text.length)>e)}getTextDirection(){const e=y()(this.text);return"neutral"==e?void 0:e}getTexts(){const e=this.getTextsAsArray();return new c.List(e)}getTextsAsArray(){let e=[];return this.nodes.forEach(t=>{"text"==t.object?e.push(t):e=e.concat(t.getTextsAsArray())}),e}getTextsAtRange(e){if((e=e.normalize(this)).isUnset)return Object(c.List)();const t=e,s=t.startKey,r=t.endKey;return new c.List(this.getTextsBetweenPositionsAsArray(s,r))}getTextsBetweenPositionsAsArray(e,t){const s=this.getDescendant(e);if(e==t)return[s];const r=this.getDescendant(t),n=this.getTextsAsArray(),o=n.indexOf(s),a=n.indexOf(r,o);return n.slice(o,a+1)}getTextsAtRangeAsArray(e){if((e=e.normalize(this)).isUnset)return[];const t=e,s=t.startKey,r=t.endKey;return this.getTextsBetweenPositionsAsArray(s,r)}hasChild(e){return!!this.getChild(e)}hasBlocks(e){const t=this.assertNode(e);return!(!t.nodes||!t.nodes.find(e=>"block"===e.object))}hasInlines(e){const t=this.assertNode(e);return!(!t.nodes||!t.nodes.find(e=>D.isInline(e)||ee.isText(e)))}hasDescendant(e){return!!this.getDescendant(e)}hasNode(e){return!!this.getNode(e)}hasVoidParent(e){return!!this.getClosestVoid(e)}insertNode(e,t){const s=this.getKeysAsArray();s.includes(t.key)&&(t=t.regenerateKey()),"text"!=t.object&&(t=t.mapDescendants(e=>s.includes(e.key)?e.regenerateKey():e));const r=this.nodes.insert(e,t);return this.set("nodes",r)}isInRange(e){e=e.normalize(this);const t=this,s=e,r=s.startKey,n=s.endKey,o=s.isCollapsed;if(t.key==r||t.key==n||t.hasDescendant(r)||t.hasDescendant(n))return!0;if(o)return!1;const a=t.getTextsAtRange(e);let i=!1;return a.forEach(e=>(t.hasDescendant(e.key)&&(i=!0),i)),i}isLeafBlock(){return"block"==this.object&&this.nodes.every(e=>"block"!=e.object)}isLeafInline(){return"inline"==this.object&&this.nodes.every(e=>"inline"!=e.object)}mergeNode(e,t){let s=this,r=s.nodes.get(e);const n=s.nodes.get(t);if(r.object!=n.object)throw new Error(`Tried to merge two nodes of different objects: "${r.object}" and "${n.object}".`);if("text"==r.object)r=r.mergeText(n);else{const e=r.nodes.concat(n.nodes);r=r.set("nodes",e)}return s=(s=(s=s.removeNode(t)).removeNode(e)).insertNode(e,r)}mapChildren(e){let t=this.nodes;return t.forEach((s,r)=>{const n=e(s,r,this.nodes);n!=s&&(t=t.set(n.key,n))}),this.set("nodes",t)}mapDescendants(e){let t=this.nodes;return t.forEach((s,r)=>{let n=s;"text"!=n.object&&(n=n.mapDescendants(e)),(n=e(n,r,this.nodes))!=s&&(t=t.set(r,n))}),this.set("nodes",t)}regenerateKey(){const e=L();return this.set("key",e)}removeDescendant(e){e=se(e);let t=this,s=t.getParent(e);if(!s)throw new Error(`Could not find a descendant node with key "${e}".`);const r=s.nodes.findIndex(t=>t.key===e),n=s.nodes.delete(r);return s=s.set("nodes",n),t=t.updateNode(s)}removeNode(e){const t=this.nodes.delete(e);return this.set("nodes",t)}splitNode(e,t){let s=this;const r=s.nodes.get(e);let n,o;if("text"==r.object){var a=r.splitText(t);n=a[0],o=a[1]}else{const e=r.nodes.take(t),s=r.nodes.skip(t);n=r.set("nodes",e),o=r.set("nodes",s).regenerateKey()}return s=(s=(s=s.removeNode(e)).insertNode(e,o)).insertNode(e,n)}updateNode(e){if(e.key==this.key)return e;let t=this.assertDescendant(e.key);return this.getAncestors(e.key).reverse().forEach(s=>{let r=s.nodes;const n=r.indexOf(t);t=s,r=r.set(n,e),s=s.set("nodes",r),e=s}),e}validate(e){return e.validateNode(this)}getFirstInvalidDescendant(e){let t=null;return this.nodes.find(s=>t=s.validate(e)?s:s.getFirstInvalidDescendant(e)),t}}function se(e){if("string"==typeof e)return e;throw new Error(`Invalid \`key\` argument! It must be a key string, but you passed: ${e}`)}T(te,"fromJS",te.fromJSON),n()(te.prototype,["areDescendantsSorted","getAncestors","getBlocksAsArray","getBlocksAtRangeAsArray","getBlocksByTypeAsArray","getChild","getClosestBlock","getClosestInline","getClosestVoid","getCommonAncestor","getDecorations","getDepth","getDescendant","getDescendantAtPath","getFirstText","getFragmentAtRange","getFurthestBlock","getFurthestInline","getFurthestAncestor","getFurthestOnlyChildAncestor","getInlinesAsArray","getInlinesAtRangeAsArray","getInlinesByTypeAsArray","getMarksAsArray","getMarksAtPosition","getOrderedMarksBetweenPositions","getInsertMarksAtRange","getKeysAsArray","getLastText","getMarksByTypeAsArray","getNextBlock","getNextSibling","getNextText","getNode","getNodeAtPath","getOffset","getOffsetAtRange","getParent","getPath","getPlaceholder","getPreviousBlock","getPreviousSibling","getPreviousText","getText","getTextAtOffset","getTextDirection","getTextsAsArray","getTextsBetweenPositionsAsArray","isLeafBlock","isLeafInline","validate","getFirstInvalidDescendant"]),Object.getOwnPropertyNames(te.prototype).forEach(e=>{"constructor"!=e&&(P.prototype[e]=te.prototype[e],D.prototype[e]=te.prototype[e],$.prototype[e]=te.prototype[e])}),P.createChildren=te.createList,D.createChildren=te.createList,$.createChildren=te.createList;const re=55296,ne=57343,oe=/\s/,ae=/['\u2018\u2019]/,ie=/[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;function ce(e,t){if(oe.test(e))return!1;if(ae.test(e)){let e=t.charAt(0);const s=le(e);if(ce(e=t.slice(0,s),t.slice(s)))return!0}return!ie.test(e)}function le(e){return t=e.charCodeAt(0),re<=t&&t<=ne?2:1;var t}function de(e){return le(e.charAt(0))}function ue(e){let t,s=0,r=0,n=!1;for(;t=e.charAt(r);){const o=le(t);if(ce(t=e.slice(r,r+o),e.slice(r+o)))n=!0,s+=o;else{if(n)break;s+=o}r+=o}return s}var he={getCharOffsetForward:function(e,t){return de(e=e.slice(t))},getCharOffsetBackward:function(e,t){return e=e.slice(0,t),de(e=Object(g.reverse)(e))},getWordOffsetBackward:function(e,t){return e=e.slice(0,t),ue(e=Object(g.reverse)(e))},getWordOffsetForward:function(e,t){return ue(e=e.slice(t))}};const fe={addMarkAtRange:function(e,t,s,r){if(void 0===r&&(r={}),t.isCollapsed)return;const n=e.getFlag("normalize",r),o=e.value.document,a=t.startKey,i=t.startOffset,c=t.endKey,l=t.endOffset;o.getTextsAtRange(t).forEach(t=>{const r=t.key;let o=0,d=t.text.length;r==a&&(o=i),r==c&&(d=l),r==a&&r==c&&(d=l-i),e.addMarkByKey(r,o,d,s,{normalize:n})})},addMarksAtRange:function(e,t,s,r){void 0===r&&(r={}),s.forEach(s=>e.addMarkAtRange(t,s,r))},deleteAtRange:function(e,t,s){if(void 0===s&&(s={}),t.isCollapsed)return;e.snapshotSelection();const r=e.getFlag("normalize",s),n=e.value;let o=t.startKey,a=t.startOffset,i=t.endKey,c=t.endOffset,l=n.document,d=l.hasVoidParent(o),u=l.hasVoidParent(i),h=l.getClosestBlock(o),f=l.getClosestBlock(i);const y=0==a&&0==c&&0==d&&o==h.getFirstText().key&&i==f.getFirstText().key;if(y&&u){const e=l.getPreviousText(i);i=e.key,c=e.text.length,u=l.hasVoidParent(i)}for(;d;){const t=l.getClosestVoid(o),s=l.getNextText(o);if(e.removeNodeByKey(t.key,{normalize:!1}),o==i)return;if(!s)return;l=e.value.document,o=s.key,a=0,d=l.hasVoidParent(o)}for(;u;){const t=l.getClosestVoid(i),s=l.getPreviousText(i);e.removeNodeByKey(t.key,{normalize:!1}),l=e.value.document,i=s.key,c=s.text.length,u=l.hasVoidParent(i)}if(o==i&&y)e.removeNodeByKey(h.key,{normalize:r});else if(o!=i){h=l.getClosestBlock(o),f=l.getClosestBlock(i);const t=l.getNode(o),s=l.getNode(i),n=t.text.length-a,d=c,u=l.getCommonAncestor(o,i),g=u.getFurthestAncestor(o),m=u.getFurthestAncestor(i),p=l.getParent(h.key),k=p.nodes.indexOf(h),v=p.nodes.indexOf(f);let A;for(A=t;A.key!=g.key;){const t=l.getParent(A.key),s=t.nodes.indexOf(A);t.nodes.slice(s+1).reverse().forEach(t=>{e.removeNodeByKey(t.key,{normalize:!1})}),A=t}const O=u.nodes.indexOf(g),x=u.nodes.indexOf(m);for(u.nodes.slice(O+1,x).reverse().forEach(t=>{e.removeNodeByKey(t.key,{normalize:!1})}),A=s;A.key!=m.key;){const t=l.getParent(A.key),s=t.nodes.indexOf(A);t.nodes.slice(0,s).reverse().forEach(t=>{e.removeNodeByKey(t.key,{normalize:!1})}),A=t}if(0!=n&&e.removeTextByKey(o,a,n,{normalize:!1}),0!=d&&e.removeTextByKey(i,0,c,{normalize:!1}),h.key!=f.key){const t=(l=e.value.document).getFurthestOnlyChildAncestor(f.key);v!=k+1&&e.moveNodeByKey(f.key,p.key,k+1,{normalize:!1}),y?e.removeNodeByKey(h.key,{normalize:!1}):e.mergeNodeByKey(f.key,{normalize:!1}),t&&e.removeNodeByKey(t.key,{normalize:!1})}r&&e.normalizeNodeByKey(u.key)}else{const t=a,s=c-a;e.removeTextByKey(o,t,s,{normalize:r})}},deleteCharBackwardAtRange:(e,t,s)=>{const r=e.value.document,n=t.startKey,o=t.startOffset,a=r.getClosestBlock(n),i=a.getOffset(n)+o,c=a.text,l=he.getCharOffsetBackward(c,i);e.deleteBackwardAtRange(t,l,s)},deleteLineBackwardAtRange:(e,t,s)=>{const r=e.value.document,n=t.startKey,o=t.startOffset,a=r.getClosestBlock(n).getOffset(n)+o;e.deleteBackwardAtRange(t,a,s)},deleteWordBackwardAtRange:(e,t,s)=>{const r=e.value.document,n=t.startKey,o=t.startOffset,a=r.getClosestBlock(n),i=a.getOffset(n)+o,c=a.text,l=he.getWordOffsetBackward(c,i);e.deleteBackwardAtRange(t,l,s)},deleteBackwardAtRange:function(e,t,s,r){if(void 0===s&&(s=1),void 0===r&&(r={}),0===s)return;const n=e.getFlag("normalize",r),o=e.value.document,a=t,i=a.startKey,c=a.focusOffset;if(t.isExpanded)return void e.deleteAtRange(t,{normalize:n});const l=o.getClosestVoid(i);if(l)return void e.removeNodeByKey(l.key,{normalize:n});const d=o.getClosestBlock(i);if(d&&d.isEmpty&&1!==o.nodes.size)return void e.removeNodeByKey(d.key,{normalize:n});if(t.isAtStartOf(o))return;const u=o.getDescendant(i);if(t.isAtStartOf(u)){const r=o.getPreviousText(u.key),a=o.getClosestBlock(r.key),i=o.getClosestVoid(r.key);if(i)return void e.removeNodeByKey(i.key,{normalize:n});if(1==s&&a!=d)return t=t.merge({anchorKey:r.key,anchorOffset:r.text.length}),void e.deleteAtRange(t,{normalize:n})}if(s<c)return t=t.merge({focusOffset:c-s,isBackward:!0}),void e.deleteAtRange(t,{normalize:n});let h=u,f=0,y=c;for(;s>y;){const e=y+(h=o.getPreviousText(h.key)).text.length;if(s<=e){f=e-s;break}y=e}t=t.merge({focusKey:h.key,focusOffset:f,isBackward:!0}),e.deleteAtRange(t,{normalize:n})},deleteCharForwardAtRange:(e,t,s)=>{const r=e.value.document,n=t.startKey,o=t.startOffset,a=r.getClosestBlock(n),i=a.getOffset(n)+o,c=a.text,l=he.getCharOffsetForward(c,i);e.deleteForwardAtRange(t,l,s)},deleteLineForwardAtRange:(e,t,s)=>{const r=e.value.document,n=t.startKey,o=t.startOffset,a=r.getClosestBlock(n),i=a.getOffset(n)+o;e.deleteForwardAtRange(t,a.text.length-i,s)},deleteWordForwardAtRange:(e,t,s)=>{const r=e.value.document,n=t.startKey,o=t.startOffset,a=r.getClosestBlock(n),i=a.getOffset(n)+o,c=a.text,l=he.getWordOffsetForward(c,i);e.deleteForwardAtRange(t,l,s)},deleteForwardAtRange:function(e,t,s,r){if(void 0===s&&(s=1),void 0===r&&(r={}),0===s)return;const n=e.getFlag("normalize",r),o=e.value.document,a=t,i=a.startKey,c=a.focusOffset;if(t.isExpanded)return void e.deleteAtRange(t,{normalize:n});const l=o.getClosestVoid(i);if(l)return void e.removeNodeByKey(l.key,{normalize:n});const d=o.getClosestBlock(i);if(d&&d.isEmpty&&1!==o.nodes.size){const t=o.getNextBlock(d.key);return e.removeNodeByKey(d.key,{normalize:n}),void(t&&t.key&&e.moveToStartOf(t))}if(t.isAtEndOf(o))return;const u=o.getDescendant(i);if(t.isAtEndOf(u)){const r=o.getNextText(u.key),a=o.getClosestBlock(r.key),i=o.getClosestVoid(r.key);if(i)return void e.removeNodeByKey(i.key,{normalize:n});if(1==s&&a!=d)return t=t.merge({focusKey:r.key,focusOffset:0}),void e.deleteAtRange(t,{normalize:n})}if(s<=u.text.length-c)return t=t.merge({focusOffset:c+s}),void e.deleteAtRange(t,{normalize:n});let h=u,f=c,y=u.text.length-c;for(;s>y;){const e=y+(h=o.getNextText(h.key)).text.length;if(s<=e){f=s-y;break}y=e}if(o.hasVoidParent(h.key)){const e=o.getClosestVoid(h.key);f=(h=o.getPreviousText(e.key)).text.length}t=t.merge({focusKey:h.key,focusOffset:f}),e.deleteAtRange(t,{normalize:n})},insertBlockAtRange:function(e,t,s,r){void 0===r&&(r={}),s=P.create(s);const n=e.getFlag("normalize",r);t.isExpanded&&(e.deleteAtRange(t),t=t.collapseToStart());const o=e.value.document;let a=t,i=a.startKey,c=a.startOffset;const l=o.getClosestBlock(i),d=o.getClosestInline(i),u=o.getParent(l.key),h=u.nodes.indexOf(l);if(l.isVoid){const r=t.isAtEndOf(l)?1:0;e.insertNodeByKey(u.key,h+r,s,{normalize:n})}else if(l.isEmpty)e.insertNodeByKey(u.key,h+1,s,{normalize:n});else if(t.isAtStartOf(l))e.insertNodeByKey(u.key,h,s,{normalize:n});else if(t.isAtEndOf(l))e.insertNodeByKey(u.key,h+1,s,{normalize:n});else{if(d&&d.isVoid){const e=t.isAtEndOf(d),s=e?o.getNextText(i):o.getPreviousText(i),r=e?t.moveToStartOf(s):t.moveToEndOf(s);i=r.startKey,c=r.startOffset}e.splitDescendantsByKey(l.key,i,c,{normalize:!1}),e.insertNodeByKey(u.key,h+1,s,{normalize:n})}n&&e.normalizeNodeByKey(u.key)},insertFragmentAtRange:function(e,t,s,r){void 0===r&&(r={});const n=e.getFlag("normalize",r);if(t.isExpanded&&(e.deleteAtRange(t,{normalize:!1}),t=e.value.document.getDescendant(t.startKey)?t.collapseToStart():t.collapseTo(t.endKey,0)),!s.nodes.size)return;s=s.mapDescendants(e=>e.regenerateKey());const o=t,a=o.startKey,i=o.startOffset;let l=e.value.document,d=l.getDescendant(a),u=l.getClosestBlock(d.key),h=u.getFurthestAncestor(d.key);const f=t.isAtStartOf(u),y=l.getParent(u.key),g=y.nodes.indexOf(u),m=s.getBlocks(),p=s.nodes.first(),k=s.nodes.last(),v=m.first(),A=m.last();if(v==A&&v.isVoid)e.insertBlockAtRange(t,v,r);else if(s.hasBlocks(p.key)||s.hasBlocks(k.key))s.nodes.reverse().forEach(s=>{e.insertBlockAtRange(t,s,r)});else{if(v!=A){const t=s.getFurthest(v.key,e=>1==e.nodes.size)||v,r=y.nodes.indexOf(u);(s=s.removeDescendant(t.key)).nodes.forEach((t,s)=>{const n=r+s+1;e.insertNodeByKey(y.key,n,t,{normalize:!1})})}if(0!=i&&e.splitDescendantsByKey(h.key,a,i,{normalize:!1}),d=(l=e.value.document).getDescendant(a),h=(u=l.getClosestBlock(a)).getFurthestAncestor(d.key),v!=A){const t=f?h:u.getNextSibling(h.key),s=t?u.nodes.skipUntil(e=>e.key==t.key):Object(c.List)(),r=A.nodes.size;s.forEach((t,s)=>{const n=r+s;e.moveNodeByKey(t.key,A.key,n,{normalize:!1})})}if(u.isEmpty)e.removeNodeByKey(u.key,{normalize:!1}),e.insertNodeByKey(y.key,g,v,{normalize:!1});else{const t=u.getFurthestAncestor(d.key),s=u.nodes.indexOf(t);v.nodes.forEach((t,r)=>{const n=s+r+(0==i?0:1);e.insertNodeByKey(u.key,n,t,{normalize:!1})})}n&&e.normalizeNodeByKey(y.key)}},insertInlineAtRange:function(e,t,s,r){void 0===r&&(r={});const n=e.getFlag("normalize",r);s=D.create(s),t.isExpanded&&(e.deleteAtRange(t,{normalize:!1}),t=t.collapseToStart());const o=e.value.document,a=t,i=a.startKey,c=a.startOffset,l=o.getParent(i),d=o.assertDescendant(i),u=l.nodes.indexOf(d);l.isVoid||(e.splitNodeByKey(i,c,{normalize:!1}),e.insertNodeByKey(l.key,u+1,s,{normalize:!1}),n&&e.normalizeNodeByKey(l.key))},insertTextAtRange:function(e,t,s,r,n){void 0===n&&(n={});let o=n.normalize;const a=e.value.document,i=t.startKey;let c=i,l=t.startOffset;if(!a.getParent(i).isVoid&&(t.isExpanded&&(e.deleteAtRange(t,{normalize:!1}),e.value.startKey!==c&&(c=e.value.startKey,l=e.value.startOffset)),void 0===o&&(o=t.isExpanded&&r&&0!==r.size),e.insertTextByKey(c,l,s,r,{normalize:!1}),o)){const s=a.getCommonAncestor(i,t.endKey),r=a.getAncestors(s.key).push(s).findLast(t=>e.value.document.getDescendant(t.key)),n=r?r.key:i;e.normalizeNodeByKey(n)}},removeMarkAtRange:function(e,t,s,r){if(void 0===r&&(r={}),t.isCollapsed)return;const n=e.getFlag("normalize",r),o=e.value.document.getTextsAtRange(t),a=t.startKey,i=t.startOffset,c=t.endKey,l=t.endOffset;o.forEach(t=>{const r=t.key;let o=0,d=t.text.length;r==a&&(o=i),r==c&&(d=l),r==a&&r==c&&(d=l-i),e.removeMarkByKey(r,o,d,s,{normalize:n})})},setBlocksAtRange:function(e,t,s,r){void 0===r&&(r={});const n=e.getFlag("normalize",r),o=e.value.document,a=o.getBlocksAtRange(t),i=t.startKey,c=t.startOffset,l=t.endKey,d=t.endOffset,u=t.isCollapsed,h=o.hasVoidParent(i),f=o.getClosestBlock(i),y=o.getClosestBlock(l);(0==u&&0==c&&0==d&&0==h&&i==f.getFirstText().key&&l==y.getFirstText().key?a.slice(0,-1):a).forEach(t=>{e.setNodeByKey(t.key,s,{normalize:n})})},setBlockAtRange:function(){i.a.deprecate("slate@0.33.0","The `setBlockAtRange` method of Slate changes has been renamed to `setBlocksAtRange`."),fe.setBlocksAtRange(...arguments)},setInlinesAtRange:function(e,t,s,r){void 0===r&&(r={});const n=e.getFlag("normalize",r);e.value.document.getInlinesAtRange(t).forEach(t=>{e.setNodeByKey(t.key,s,{normalize:n})})},setInlineAtRange:function(){i.a.deprecate("slate@0.33.0","The `setInlineAtRange` method of Slate changes has been renamed to `setInlinesAtRange`."),fe.setInlinesAtRange(...arguments)},splitBlockAtRange:function(e,t,s,r){void 0===s&&(s=1),void 0===r&&(r={});const n=e.getFlag("normalize",r),o=t,a=o.startKey,i=o.startOffset,c=o.endOffset,l=o.endKey,d=e.value.document;let u=d.assertDescendant(a),h=d.getClosestBlock(u.key),f=0;for(;h&&"block"==h.object&&f<s;)u=h,h=d.getClosestBlock(h.key),f++;if(e.splitDescendantsByKey(u.key,a,i,{normalize:n&&t.isCollapsed}),t.isExpanded){t.isBackward&&(t=t.flip());const s=e.value.document.getNextBlock(u.key);t=t.moveAnchorToStartOf(s),a===l&&(t=t.moveFocusTo(t.anchorKey,c-i)),e.deleteAtRange(t,{normalize:n})}},splitInlineAtRange:function(e,t,s,r){void 0===s&&(s=1/0),void 0===r&&(r={});const n=e.getFlag("normalize",r);t.isExpanded&&(e.deleteAtRange(t,{normalize:n}),t=t.collapseToStart());const o=t,a=o.startKey,i=o.startOffset,c=e.value.document;let l=c.assertDescendant(a),d=c.getClosestInline(l.key),u=0;for(;d&&"inline"==d.object&&u<s;)l=d,d=c.getClosestInline(d.key),u++;e.splitDescendantsByKey(l.key,a,i,{normalize:n})},toggleMarkAtRange:function(e,t,s,r){if(void 0===r&&(r={}),t.isCollapsed)return;s=R.create(s);const n=e.getFlag("normalize",r);e.value.document.getActiveMarksAtRange(t).some(e=>e.equals(s))?e.removeMarkAtRange(t,s,{normalize:n}):e.addMarkAtRange(t,s,{normalize:n})},unwrapBlockAtRange:function(e,t,s,r){void 0===r&&(r={}),s=te.createProperties(s);const n=e.getFlag("normalize",r),o=e.value.document.getBlocksAtRange(t);o.map(t=>e.value.document.getClosest(t.key,e=>"block"==e.object&&((null==s.type||e.type==s.type)&&((null==s.isVoid||e.isVoid==s.isVoid)&&!(null!=s.data&&!e.data.isSuperset(s.data)))))).filter(e=>e).toOrderedSet().toList().forEach(t=>{const s=t.nodes.first(),r=t.nodes.last(),n=e.value.document.getParent(t.key),a=n.nodes.indexOf(t),i=t.nodes.filter(e=>o.some(t=>e==t||e.hasDescendant(t.key))),c=i.first(),l=i.last();if(s==c&&r==l)t.nodes.forEach((t,s)=>{e.moveNodeByKey(t.key,n.key,a+s,{normalize:!1})}),e.removeNodeByKey(t.key,{normalize:!1});else if(r==l)t.nodes.skipUntil(e=>e==c).forEach((t,s)=>{e.moveNodeByKey(t.key,n.key,a+1+s,{normalize:!1})});else if(s==c)t.nodes.takeUntil(e=>e==l).push(l).forEach((t,s)=>{e.moveNodeByKey(t.key,n.key,a+s,{normalize:!1})});else{const s=c.getFirstText();e.splitDescendantsByKey(t.key,s.key,0,{normalize:!1}),i.forEach((t,s)=>{if(0==s){const s=t;t=e.value.document.getNextBlock(t.key),e.removeNodeByKey(s.key,{normalize:!1})}e.moveNodeByKey(t.key,n.key,a+1+s,{normalize:!1})})}}),n&&e.normalizeDocument()},unwrapInlineAtRange:function(e,t,s,r){void 0===r&&(r={}),s=te.createProperties(s);const n=e.getFlag("normalize",r),o=e.value.document;o.getTextsAtRange(t).map(e=>o.getClosest(e.key,e=>"inline"==e.object&&((null==s.type||e.type==s.type)&&((null==s.isVoid||e.isVoid==s.isVoid)&&!(null!=s.data&&!e.data.isSuperset(s.data)))))).filter(e=>e).toOrderedSet().toList().forEach(t=>{const s=e.value.document.getParent(t.key),r=s.nodes.indexOf(t);t.nodes.forEach((t,n)=>{e.moveNodeByKey(t.key,s.key,r+n,{normalize:!1})})}),n&&e.normalizeDocument()},wrapBlockAtRange:function(e,t,s,r){void 0===r&&(r={}),s=(s=P.create(s)).set("nodes",s.nodes.clear());const n=e.getFlag("normalize",r),o=e.value.document,a=o.getBlocksAtRange(t),i=a.first(),c=a.last();let l,d,u;if(1===a.length?(l=o.getParent(i.key),d=a):l=o.getClosest(i.key,e=>!!o.getClosest(c.key,t=>e==t)),null==l&&(l=o),null==d){const e=l.nodes.reduce((e,t,s)=>((t==i||t.hasDescendant(i.key))&&(e[0]=s),(t==c||t.hasDescendant(c.key))&&(e[1]=s),e),[]);u=e[0],d=l.nodes.slice(e[0],e[1]+1)}null==u&&(u=l.nodes.indexOf(d.first())),e.insertNodeByKey(l.key,u,s,{normalize:!1}),d.forEach((t,r)=>{e.moveNodeByKey(t.key,s.key,r,{normalize:!1})}),n&&e.normalizeNodeByKey(l.key)},wrapInlineAtRange:function(e,t,s,r){void 0===r&&(r={});let n=e.value.document;const o=e.getFlag("normalize",r),a=t.startKey,i=t.startOffset,l=t.endKey,d=t.endOffset;if(t.isCollapsed){const t=n.getClosestInline(a);if(!t.isVoid)return;return e.wrapInlineByKey(t.key,s,r)}s=(s=D.create(s)).set("nodes",s.nodes.clear());const u=n.getBlocksAtRange(t);let h=n.getClosestBlock(a),f=n.getClosestBlock(l);const y=n.getClosestInline(a),g=n.getClosestInline(l);let m=h.getFurthestAncestor(a),p=f.getFurthestAncestor(l);y&&y==g||(e.splitDescendantsByKey(p.key,l,d,{normalize:!1}),e.splitDescendantsByKey(m.key,a,i,{normalize:!1})),h=(n=e.value.document).getDescendant(h.key),f=n.getDescendant(f.key),m=h.getFurthestAncestor(a),p=f.getFurthestAncestor(l);const k=h.nodes.indexOf(m),v=f.nodes.indexOf(p);if(y&&y==g){const r=h.getTextsAtRange(t).get(0).splitText(i)[1].splitText(d-i)[0];s=s.set("nodes",Object(c.List)([r])),fe.insertInlineAtRange(e,t,s,{normalize:!1});const n=s.getFirstText().key,o={anchorKey:n,focusKey:n,anchorOffset:0,focusOffset:d-i,isFocused:!0};e.select(o)}else if(h==f){m=(h=(n=e.value.document).getClosestBlock(a)).getFurthestAncestor(a);const t=n.getNextSibling(m.key),r=h.nodes.indexOf(t),i=a==l?t:h.getFurthestAncestor(l),c=h.nodes.skipUntil(e=>e==t).takeUntil(e=>e==i).push(i),d=s.regenerateKey();e.insertNodeByKey(h.key,r,d,{normalize:!1}),c.forEach((t,s)=>{e.moveNodeByKey(t.key,d.key,s,{normalize:!1})}),o&&e.normalizeNodeByKey(h.key)}else{const t=h.nodes.slice(k+1),r=f.nodes.slice(0,v+1),n=s.regenerateKey(),a=s.regenerateKey();e.insertNodeByKey(h.key,k+1,n,{normalize:!1}),e.insertNodeByKey(f.key,v,a,{normalize:!1}),t.forEach((t,s)=>{e.moveNodeByKey(t.key,n.key,s,{normalize:!1})}),r.forEach((t,s)=>{e.moveNodeByKey(t.key,a.key,s,{normalize:!1})}),o&&e.normalizeNodeByKey(h.key).normalizeNodeByKey(f.key),u.slice(1,-1).forEach(t=>{const r=s.regenerateKey();e.insertNodeByKey(t.key,0,r,{normalize:!1}),t.nodes.forEach((t,s)=>{e.moveNodeByKey(t.key,r.key,s,{normalize:!1})}),o&&e.normalizeNodeByKey(t.key)})}},wrapTextAtRange:function(e,t,s,r,n){void 0===r&&(r=s),void 0===n&&(n={});const o=e.getFlag("normalize",n),a=t.startKey,i=t.endKey,c=t.collapseToStart();let l=t.collapseToEnd();a==i&&(l=l.move(s.length)),e.insertTextAtRange(c,s,[],{normalize:o}),e.insertTextAtRange(l,r,[],{normalize:o})}},ye={addMarkByKey:function(e,t,s,r,n,o){void 0===o&&(o={}),n=R.create(n);const a=e.getFlag("normalize",o),i=e.value,c=i.document,l=c.getPath(t),d=c.getNode(t).getLeaves(),u=[],h=s,f=s+r;let y=0;if(d.forEach(e=>{const t=y,s=t+e.text.length;if(y+=e.text.length,s<h||f<t)return;if(e.marks.has(n))return;const r=Math.max(t,h),o=Math.min(s,f);u.push({type:"add_mark",value:i,path:l,offset:r,length:o-r,mark:n})}),e.applyOperations(u),a){const s=c.getParent(t);e.normalizeNodeByKey(s.key)}},insertFragmentByKey:function(e,t,s,r,n){void 0===n&&(n={});const o=e.getFlag("normalize",n);r.nodes.forEach((r,n)=>{e.insertNodeByKey(t,s+n,r)}),o&&e.normalizeNodeByKey(t)},insertNodeByKey:function(e,t,s,r,n){void 0===n&&(n={});const o=e.getFlag("normalize",n),a=e.value,i=a.document.getPath(t);e.applyOperation({type:"insert_node",value:a,path:[...i,s],node:r}),o&&e.normalizeNodeByKey(t)},insertTextByKey:function(e,t,s,r,n,o){void 0===o&&(o={});const a=e.getFlag("normalize",o),i=e.value,c=i.document,l=c.getPath(t),d=c.getNode(t);if(n=n||d.getMarksAtIndex(s),e.applyOperation({type:"insert_text",value:i,path:l,offset:s,text:r,marks:n}),a){const s=c.getParent(t);e.normalizeNodeByKey(s.key)}},mergeNodeByKey:function(e,t,s){void 0===s&&(s={});const r=e.getFlag("normalize",s),n=e.value,o=n.document,a=o.getPath(t),i=o.getDescendant(t),c=o.getPreviousSibling(t);if(!c)throw new Error(`Unable to merge node with key "${t}", no previous key.`);const l="text"==c.object?c.text.length:c.nodes.size;if(e.applyOperation({type:"merge_node",value:n,path:a,position:l,properties:{type:i.type,data:i.data},target:null}),r){const s=o.getParent(t);e.normalizeNodeByKey(s.key)}},moveNodeByKey:function(e,t,s,r,n){void 0===n&&(n={});const o=e.getFlag("normalize",n),a=e.value,i=a.document,c=i.getPath(t),l=i.getPath(s);if(e.applyOperation({type:"move_node",value:a,path:c,newPath:[...l,r]}),o){const r=i.getCommonAncestor(t,s);e.normalizeNodeByKey(r.key)}},removeMarkByKey:function(e,t,s,r,n,o){void 0===o&&(o={}),n=R.create(n);const a=e.getFlag("normalize",o),i=e.value,c=i.document,l=c.getPath(t),d=c.getNode(t).getLeaves(),u=[],h=s,f=s+r;let y=0;if(d.forEach(e=>{const t=y,s=t+e.text.length;if(y+=e.text.length,s<h||f<t)return;if(!e.marks.has(n))return;const r=Math.max(t,h),o=Math.min(s,f);u.push({type:"remove_mark",value:i,path:l,offset:r,length:o-r,mark:n})}),e.applyOperations(u),a){const s=c.getParent(t);e.normalizeNodeByKey(s.key)}},removeAllMarksByKey:function(e,t,s){void 0===s&&(s={});const r=e.state.document.getNode(t);("text"===r.object?[r]:r.getTextsAsArray()).forEach(t=>{t.getMarksAsArray().forEach(r=>{e.removeMarkByKey(t.key,0,t.text.length,r,s)})})},removeNodeByKey:function(e,t,s){void 0===s&&(s={});const r=e.getFlag("normalize",s),n=e.value,o=n.document,a=o.getPath(t),i=o.getNode(t);if(e.applyOperation({type:"remove_node",value:n,path:a,node:i}),r){const s=o.getParent(t);e.normalizeNodeByKey(s.key)}},setTextByKey:function(e,t,s,r,n){void 0===n&&(n={});const o=e.value.document.getDescendant(t);e.replaceTextByKey(t,0,o.text.length,s,r,n)},replaceTextByKey:(e,t,s,r,n,o,a)=>{const i=e.value.document,c=i.getDescendant(t);r+s>c.text.length&&(r=c.text.length-s);const l=H.create({anchorKey:t,focusKey:t,anchorOffset:s,focusOffset:s+r});let d=i.getActiveMarksAtRange(l);e.removeTextByKey(t,s,r,{normalize:!1}),o?d&&(d=d.filter(e=>!o.find(t=>e.type===t.type)),o=d.merge(o)):o=d||[],e.insertTextByKey(t,s,n,o,a)},removeTextByKey:function(e,t,s,r,n){void 0===n&&(n={});const o=e.getFlag("normalize",n),a=e.value,i=a.document,c=i.getPath(t),l=i.getNode(t),d=l.getLeaves(),u=l.text,h=[],f=s,y=s+r;let g=0;if(d.forEach(e=>{const t=g,s=t+e.text.length;if(g+=e.text.length,s<f||y<t)return;const r=Math.max(t,f),n=Math.min(s,y),o=u.slice(r,n);h.push({type:"remove_text",value:a,path:c,offset:r,text:o,marks:e.marks})}),e.applyOperations(h.reverse()),o){const s=i.getClosestBlock(t);e.normalizeNodeByKey(s.key)}},replaceNodeByKey:function(e,t,s,r){void 0===r&&(r={}),s=te.create(s);const n=e.getFlag("normalize",r),o=e.value.document,a=o.getNode(t),i=o.getParent(t),c=i.nodes.indexOf(a);e.removeNodeByKey(t,{normalize:!1}),e.insertNodeByKey(i.key,c,s,{normalize:!1}),n&&e.normalizeNodeByKey(i.key)},setMarkByKey:function(e,t,s,r,n,o,a){void 0===a&&(a={}),n=R.create(n),o=R.createProperties(o);const i=e.getFlag("normalize",a),c=e.value,l=c.document,d=l.getPath(t);if(e.applyOperation({type:"set_mark",value:c,path:d,offset:s,length:r,mark:n,properties:o}),i){const s=l.getParent(t);e.normalizeNodeByKey(s.key)}},setNodeByKey:function(e,t,s,r){void 0===r&&(r={}),s=te.createProperties(s);const n=e.getFlag("normalize",r),o=e.value,a=o.document,i=a.getPath(t),c=a.getNode(t);e.applyOperation({type:"set_node",value:o,path:i,node:c,properties:s}),n&&e.normalizeNodeByKey(c.key)},splitNodeByKey:function(e,t,s,r){void 0===r&&(r={});const n=r,o=n.normalize,a=void 0===o||o,i=n.target,c=void 0===i?null:i,l=e.value,d=l.document,u=d.getPath(t),h=d.getDescendantAtPath(u);if(e.applyOperation({type:"split_node",value:l,path:u,position:s,properties:{type:h.type,data:h.data},target:c}),a){const s=d.getParent(t);e.normalizeNodeByKey(s.key)}},splitDescendantsByKey:function(e,t,s,r,n){if(void 0===n&&(n={}),t==s)return void e.splitNodeByKey(s,r,n);const o=e.getFlag("normalize",n),a=e.value.document,i=a.getNode(s);let c,l;if(a.getAncestors(s).skipUntil(e=>e.key==t).reverse().unshift(i).forEach(t=>{const s=null==l?null:l;l=c?t.nodes.indexOf(c)+1:r,c=t,e.splitNodeByKey(t.key,l,{normalize:!1,target:s})}),o){const s=a.getParent(t);e.normalizeNodeByKey(s.key)}},unwrapInlineByKey:(e,t,s,r)=>{const n=e.value,o=n.document,a=n.selection,i=o.assertDescendant(t),c=i.getFirstText(),l=i.getLastText(),d=a.moveToRangeOf(c,l);e.unwrapInlineAtRange(d,s,r)},unwrapBlockByKey:(e,t,s,r)=>{const n=e.value,o=n.document,a=n.selection,i=o.assertDescendant(t),c=i.getFirstText(),l=i.getLastText(),d=a.moveToRangeOf(c,l);e.unwrapBlockAtRange(d,s,r)},unwrapNodeByKey:function(e,t,s){void 0===s&&(s={});const r=e.getFlag("normalize",s),n=e.value.document,o=n.getParent(t),a=o.getChild(t),i=o.nodes.indexOf(a),c=0===i,l=i===o.nodes.size-1,d=n.getParent(o.key),u=d.nodes.indexOf(o);1===o.nodes.size?(e.moveNodeByKey(t,d.key,u,{normalize:!1}),e.removeNodeByKey(o.key,s)):c?e.moveNodeByKey(t,d.key,u,s):l?e.moveNodeByKey(t,d.key,u+1,s):(e.splitNodeByKey(o.key,i,{normalize:!1}),e.moveNodeByKey(t,d.key,u+1,{normalize:!1}),r&&e.normalizeNodeByKey(d.key))},wrapBlockByKey:(e,t,s,r)=>{s=(s=P.create(s)).set("nodes",s.nodes.clear());const n=e.value.document,o=n.assertDescendant(t),a=n.getParent(o.key),i=a.nodes.indexOf(o);e.insertNodeByKey(a.key,i,s,{normalize:!1}),e.moveNodeByKey(o.key,s.key,0,r)},wrapInlineByKey:(e,t,s,r)=>{s=(s=D.create(s)).set("nodes",s.nodes.clear());const n=e.value.document,o=n.assertDescendant(t),a=n.getParent(o.key),i=a.nodes.indexOf(o);e.insertNodeByKey(a.key,i,s,{normalize:!1}),e.moveNodeByKey(o.key,s.key,0,r)},wrapNodeByKey:(e,t,s)=>{"block"!=(s=(s=te.create(s)).set("nodes",s.nodes.clear())).object?"inline"!=s.object||e.wrapInlineByKey(t,s):e.wrapBlockByKey(t,s)}},ge={add_mark:["value","path","offset","length","mark"],insert_node:["value","path","node"],insert_text:["value","path","offset","text","marks"],merge_node:["value","path","position","properties","target"],move_node:["value","path","newPath"],remove_mark:["value","path","offset","length","mark"],remove_node:["value","path","node"],remove_text:["value","path","offset","text","marks"],set_mark:["value","path","offset","length","mark","properties"],set_node:["value","path","node","properties"],set_selection:["value","selection","properties"],set_value:["value","properties"],split_node:["value","path","position","properties","target"]},me=d()("slate:history"),pe={redos:new c.Stack,undos:new c.Stack};class ke extends(Object(c.Record)(pe)){static create(e){if(void 0===e&&(e={}),ke.isHistory(e))return e;if(a()(e))return ke.fromJS(e);throw new Error(`\`History.create\` only accepts objects or histories, but you passed it: ${e}`)}static createOperationsList(e){if(void 0===e&&(e=[]),c.List.isList(e))return e;if(Array.isArray(e))return new c.List(e);throw new Error(`\`History.createList\` only accepts arrays or lists, but you passed it: ${e}`)}static fromJS(e){const t=e.redos,s=void 0===t?[]:t,r=e.undos,n=void 0===r?[]:r;return new ke({redos:new c.Stack(s.map(this.createOperationsList)),undos:new c.Stack(n.map(this.createOperationsList))})}static fromJSON(e){return i.a.deprecate("slate@0.35.0","fromJSON methods are deprecated, use fromJS instead"),ke.fromJS(e)}get object(){return"history"}get kind(){return i.a.deprecate("slate@0.32.0","The `kind` property of Slate objects has been renamed to `object`."),this.object}save(e,t){void 0===t&&(t={});let s=this,r=s,n=r.undos,o=r.redos,a=t,i=a.merge,l=a.skip;const d=n.peek(),u=d&&d.last();if(null==l&&(l=function(e,t){if(!t)return!1;return"set_selection"==e.type&&"set_selection"==t.type}(e,u)),l)return s;if(null==i&&(i=function(e,t){if(!t)return!1;return"set_selection"==e.type&&"set_selection"==t.type||"insert_text"==e.type&&"insert_text"==t.type&&e.offset==t.offset+t.text.length&&p()(e.path,t.path)||"remove_text"==e.type&&"remove_text"==t.type&&e.offset+e.text.length==t.offset&&p()(e.path,t.path)}(e,u)),me("save",{operation:e,merge:i}),i&&d){const t=d.push(e);n=(n=n.pop()).push(t)}else{const t=new c.List([e]);n=n.push(t)}return n.size>100&&(n=n.take(100)),o=o.clear(),s=s.set("undos",n).set("redos",o)}toJS(){return{object:this.object,redos:this.redos.toJS(),undos:this.undos.toJS()}}toJSON(){return i.a.deprecate("slate@0.35.0","toJSON methods are deprecated, use toJS instead"),this.toJS()}}T(ke,"isHistory",N.bind(null,"HISTORY")),ke.prototype[w.HISTORY]=!0;const ve=[{validateNode(e){if("document"!=e.object)return;const t=e.nodes.filter(e=>"block"!=e.object);return t.size?e=>{t.forEach(t=>{e.removeNodeByKey(t.key,{normalize:!1})})}:void 0}},{validateNode(e){if("block"!=e.object)return;const t=e.nodes.first();if(!t)return;const s="block"==t.object?["block"]:["inline","text"],r=e.nodes.filter(e=>!s.includes(e.object));return r.size?e=>{r.forEach(t=>{e.removeNodeByKey(t.key,{normalize:!1})})}:void 0}},{validateNode(e){if("inline"!=e.object)return;const t=e.nodes.filter(e=>"inline"!=e.object&&"text"!=e.object);return t.size?e=>{t.forEach(t=>{e.removeNodeByKey(t.key,{normalize:!1})})}:void 0}},{validateNode(e){if(!("block"!=e.object&&"inline"!=e.object||e.nodes.size>0))return t=>{const s=ee.create();t.insertNodeByKey(e.key,0,s,{normalize:!1})}}},{validateNode(e){if("inline"!=e.object&&"block"!=e.object)return;const t=e.nodes.filter(e=>"inline"===e.object&&e.isEmpty);return t.size?s=>{if(e.nodes.size==t.size){const t=ee.create();s.insertNodeByKey(e.key,1,t,{normalize:!1})}t.forEach(e=>{s.removeNodeByKey(e.key,{normalize:!1})})}:void 0}},{validateNode(e){if("block"!=e.object&&"inline"!=e.object)return;const t=e.nodes.reduce((t,s,r)=>{if("inline"!==s.object)return t;const n=r>0?e.nodes.get(r-1):null,o=e.nodes.get(r+1),a=!n,i=!o||"inline"==o.object;return(i||a)&&(t=t.push({insertAfter:i,insertBefore:a,index:r})),t},new c.List);return t.size?s=>{let r=0;t.forEach(t=>{let n=t.index,o=t.insertAfter;t.insertBefore&&(s.insertNodeByKey(e.key,r+n,ee.create(),{normalize:!1}),r++),o&&(s.insertNodeByKey(e.key,r+n+1,ee.create(),{normalize:!1}),r++)})}:void 0}},{validateNode(e){if("block"!=e.object&&"inline"!=e.object)return;const t=e.nodes.map((t,s)=>{const r=e.nodes.get(s+1);if("text"==t.object&&r&&"text"==r.object)return r}).filter(Boolean);return t.size?e=>{t.reverse().forEach(t=>{e.mergeNodeByKey(t.key,{normalize:!1})})}:void 0}},{validateNode(e){if("block"!=e.object&&"inline"!=e.object)return;const t=e.nodes;if(t.size<=1)return;const s=t.filter((e,s)=>{if("text"!=e.object)return;if(e.text.length>0)return;const r=s>0?t.get(s-1):null,n=t.get(s+1);return!(!r&&"inline"==n.object||!n&&"inline"==r.object||n&&r&&"inline"==n.object&&"inline"==r.object)||void 0});return s.size?e=>{s.forEach(t=>{e.removeNodeByKey(t.key,{normalize:!1})})}:void 0}}],Ae={plugins:[]};class Oe extends(Object(c.Record)(Ae)){static create(e){void 0===e&&(e={});const t=e.plugins;return new Oe({plugins:void 0===t?[]:t})}static isStack(e){return!(!e||!e[w.STACK])}get object(){return"stack"}get kind(){return i.a.deprecate("slate@0.32.0","The `kind` property of Slate objects has been renamed to `object`."),this.object}getPluginsWith(e){return this.plugins.filter(t=>null!=t[e])}find(e){const t=this.getPluginsWith(e);for(var s=arguments.length,r=new Array(s>1?s-1:0),n=1;n<s;n++)r[n-1]=arguments[n];for(const o of t){const t=o[e](...r);if(null!=t)return t}}map(e){const t=this.getPluginsWith(e),s=[];for(var r=arguments.length,n=new Array(r>1?r-1:0),o=1;o<r;o++)n[o-1]=arguments[o];for(const a of t){const t=a[e](...n);null!=t&&s.push(t)}return s}run(e){const t=this.getPluginsWith(e);for(var s=arguments.length,r=new Array(s>1?s-1:0),n=1;n<s;n++)r[n-1]=arguments[n];for(const o of t){if(null!=o[e](...r))return}}render(e,t){for(var s=arguments.length,r=new Array(s>2?s-2:0),n=2;n<s;n++)r[n-2]=arguments[n];return this.getPluginsWith(e).reduceRight((s,n)=>{if(!n[e])return s;const o=n[e](t,...r);return null==o?s:(t.children=o,o)},void 0===t.children?null:t.children)}}Oe.prototype[w.STACK]=!0,n()(Oe.prototype,["getPluginsWith"]);const xe=d()("slate:schema"),Be={stack:Oe.create(),document:{},blocks:{},inlines:{}};class Ke extends(Object(c.Record)(Be)){static create(e){if(void 0===e&&(e={}),Ke.isSchema(e))return e;if(a()(e))return Ke.fromJS(e);throw new Error(`\`Schema.create\` only accepts objects or schemas, but you passed it: ${e}`)}static fromJS(e){if(Ke.isSchema(e))return e;let t=e.plugins;if(e.rules)throw new Error("Schemas in Slate have changed! They are no longer accept a `rules` property.");if(e.nodes)throw new Error("Schemas in Slate have changed! They are no longer accept a `nodes` property.");t||(t=[{schema:e}]);const s=function(e){void 0===e&&(e=[]);const t={document:{},blocks:{},inlines:{}};return e.slice().reverse().forEach(e=>{if(!e.schema)return;if(e.schema.rules)throw new Error("Schemas in Slate have changed! They are no longer accept a `rules` property.");if(e.schema.nodes)throw new Error("Schemas in Slate have changed! They are no longer accept a `nodes` property.");const s=e.schema,r=s.document,n=void 0===r?{}:r,o=s.blocks,a=void 0===o?{}:o,i=s.inlines,c=void 0===i?{}:i,l=function(e){return b({data:{},nodes:null},e)}(n),d={},u={};for(const t in a)d[t]=Te("block",t,a[t]);for(const t in c)u[t]=Te("inline",t,c[t]);v()(t.document,l,be),v()(t.blocks,d,be),v()(t.inlines,u,be)}),t}(t),r=Oe.create({plugins:[...ve,...t]});return new Ke(b({},s,{stack:r}))}static fromJSON(e){return i.a.deprecate("slate@0.35.0","fromJSON methods are deprecated, use fromJS instead"),Ke.fromJS(e)}static isSchema(e){return!(!e||!e[w.SCHEMA])}get object(){return"schema"}get kind(){return i.a.deprecate("slate@0.32.0","The `kind` property of Slate objects has been renamed to `object`."),this.object}getRule(e){switch(e.object){case"document":return this.document;case"block":return this.blocks[e.type];case"inline":return this.inlines[e.type]}}getParentRules(){const e=this.blocks,t=this.inlines,s={};for(const r in e){const t=e[r];null!=t.parent&&(s[r]=t)}for(const r in t){const e=t[r];null!=e.parent&&(s[r]=e)}return 0==Object.keys(s).length?null:s}fail(e,t){return s=>{xe("normalizing",{violation:e,context:t});const r=t.rule,n=s.operations.size;r.normalize&&r.normalize(s,e,t),s.operations.size>n||this.normalize(s,e,t)}}normalize(e,t,s){switch(t){case A.CHILD_OBJECT_INVALID:case A.CHILD_TYPE_INVALID:case A.CHILD_UNKNOWN:case A.FIRST_CHILD_OBJECT_INVALID:case A.FIRST_CHILD_TYPE_INVALID:case A.LAST_CHILD_OBJECT_INVALID:case A.LAST_CHILD_TYPE_INVALID:{const t=s.child,r=s.node;return"text"==t.object&&"block"==r.object&&1==r.nodes.size?e.removeNodeByKey(r.key):e.removeNodeByKey(t.key)}case A.CHILD_REQUIRED:case A.NODE_TEXT_INVALID:case A.PARENT_OBJECT_INVALID:case A.PARENT_TYPE_INVALID:{const t=s.node;return"document"==t.object?t.nodes.forEach(t=>e.removeNodeByKey(t.key)):e.removeNodeByKey(t.key)}case A.NODE_DATA_INVALID:{const t=s.node,r=s.key;return void 0===t.data.get(r)&&"document"!=t.object?e.removeNodeByKey(t.key):e.setNodeByKey(t.key,{data:t.data.delete(r)})}case A.NODE_IS_VOID_INVALID:{const t=s.node;return e.setNodeByKey(t.key,{isVoid:!t.isVoid})}case A.NODE_MARK_INVALID:{const t=s.node,r=s.mark;return t.getTexts().forEach(t=>e.removeMarkByKey(t.key,0,t.text.length,r))}}}validateNode(e){const t=this.stack.find("validateNode",e);if(t)return t;if("text"==e.object)return;const s=this.getRule(e)||{},r=this.getParentRules(),n={node:e,rule:s};if(null!=s.isVoid&&e.isVoid!=s.isVoid)return this.fail(A.NODE_IS_VOID_INVALID,n);if(null!=s.data)for(const c in s.data){const t=s.data[c],r=e.data.get(c);if(!t(r))return this.fail(A.NODE_DATA_INVALID,b({},n,{key:c,value:r}))}if(null!=s.marks){const t=e.getMarks().toArray();for(const e of t)if(!s.marks.some(t=>t.type===e.type))return this.fail(A.NODE_MARK_INVALID,b({},n,{mark:e}))}if(null!=s.text){const t=e.text;if(!s.text.test(t))return this.fail(A.NODE_TEXT_INVALID,b({},n,{text:t}))}if(null!=s.first){const t=s.first,r=t.objects,o=t.types,a=e.nodes.first();if(a&&r&&!r.includes(a.object))return this.fail(A.FIRST_CHILD_OBJECT_INVALID,b({},n,{child:a}));if(a&&o&&!o.includes(a.type))return this.fail(A.FIRST_CHILD_TYPE_INVALID,b({},n,{child:a}))}if(null!=s.last){const t=s.last,r=t.objects,o=t.types,a=e.nodes.last();if(a&&r&&!r.includes(a.object))return this.fail(A.LAST_CHILD_OBJECT_INVALID,b({},n,{child:a}));if(a&&o&&!o.includes(a.type))return this.fail(A.LAST_CHILD_TYPE_INVALID,b({},n,{child:a}))}if(null!=s.nodes||null!=r){const t=e.nodes.toArray(),c=null!=s.nodes?s.nodes.slice():[];let l,d,u,h,f,y;function o(){return l=null==l?null:0,h=c.shift(),d=h&&(null==h.min?0:h.min),f=h&&(null==h.max?1/0:h.max),!!h}function a(){return l=null==l?0:l+1,y=t[u=null==u?0:u+1],null!=f&&l==f&&o(),!!y}function i(){l-=1,u-=1}for(null!=s.nodes&&o();a();){if(null!=r&&"text"!=y.object&&y.type in r){const t=r[y.type];if(null!=t.parent.objects&&!t.parent.objects.includes(e.object))return this.fail(A.PARENT_OBJECT_INVALID,{node:y,parent:e,rule:t});if(null!=t.parent.types&&!t.parent.types.includes(e.type))return this.fail(A.PARENT_TYPE_INVALID,{node:y,parent:e,rule:t})}if(null!=s.nodes){if(!h)return this.fail(A.CHILD_UNKNOWN,b({},n,{child:y,index:u}));if(null!=h.objects&&!h.objects.includes(y.object)){if(l>=d&&o()){i();continue}return this.fail(A.CHILD_OBJECT_INVALID,b({},n,{child:y,index:u}))}if(null!=h.types&&!h.types.includes(y.type)){if(l>=d&&o()){i();continue}return this.fail(A.CHILD_TYPE_INVALID,b({},n,{child:y,index:u}))}}}if(null!=s.nodes)for(;null!=d;){if(l<d)return this.fail(A.CHILD_REQUIRED,b({},n,{index:u}));o()}}}toJS(){return{object:this.object,document:this.document,blocks:this.blocks,inlines:this.inlines}}toJSON(){return i.a.deprecate("slate@0.35.0","toJSON methods are deprecated, use toJS instead"),this.toJS()}}function Te(e,t,s){return b({data:{},isVoid:null,nodes:null,first:null,last:null,parent:null,text:null},s)}function be(e,t,s){return"objects"==s||"types"==s||"marks"==s?null==e?t:e.concat(t):null==t?e:t}Ke.prototype[w.SCHEMA]=!0,n()(Ke.prototype,["getParentRules"]);const Se={data:new c.Map,decorations:null,document:$.create(),history:ke.create(),schema:Ke.create(),selection:H.create()};class we extends(Object(c.Record)(Se)){static create(e,t){if(void 0===e&&(e={}),void 0===t&&(t={}),we.isValue(e))return e;if(a()(e))return we.fromJS(e,t);throw new Error(`\`Value.create\` only accepts objects or values, but you passed it: ${e}`)}static createProperties(e){if(void 0===e&&(e={}),we.isValue(e))return{data:e.data,decorations:e.decorations,schema:e.schema};if(a()(e)){const t={};return"data"in e&&(t.data=I.create(e.data)),"decorations"in e&&(t.decorations=H.createList(e.decorations)),"schema"in e&&(t.schema=Ke.create(e.schema)),t}throw new Error(`\`Value.createProperties\` only accepts objects or values, but you passed it: ${e}`)}static fromJS(e,t){void 0===t&&(t={});let s=e.document,r=void 0===s?{}:s,n=e.selection,o=void 0===n?{}:n,a=e.schema,i=void 0===a?{}:a,l=e.history,d=void 0===l?{}:l,u=new c.Map;r=$.fromJS(r);const h=o,f=h.anchorPath,y=h.focusPath,g=h.anchorKey,m=h.focusKey;if(void 0!==f&&void 0===g&&(o.anchorKey=r.assertPath(f).key),void 0!==y&&void 0===m&&(o.focusKey=r.assertPath(y).key),o=H.fromJS(o),i=Ke.fromJS(i),d=ke.fromJS(d),t.plugins)for(const c of t.plugins)c.data&&(u=u.merge(c.data));if("data"in e&&(u=u.merge(e.data)),o.isUnset){const e=r.getFirstText();e&&(o=o.collapseToStartOf(e))}let p=new we({data:u,document:r,selection:o,schema:i,history:d});return!1!==t.normalize&&(p=p.change({save:!1}).normalize().value),p}static fromJSON(e){return i.a.deprecate("slate@0.35.0","fromJSON methods are deprecated, use fromJS instead"),we.fromJS(e)}static isValue(e){return!(!e||!e[w.VALUE])}get object(){return"value"}get kind(){return i.a.deprecate("slate@0.32.0","The `kind` property of Slate objects has been renamed to `object`."),this.object}get hasUndos(){return this.history.undos.size>0}get hasRedos(){return this.history.redos.size>0}get isBlurred(){return this.selection.isBlurred}get isFocused(){return this.selection.isFocused}get isCollapsed(){return this.selection.isCollapsed}get isExpanded(){return this.selection.isExpanded}get isBackward(){return this.selection.isBackward}get isForward(){return this.selection.isForward}get startKey(){return this.selection.startKey}get endKey(){return this.selection.endKey}get startOffset(){return this.selection.startOffset}get endOffset(){return this.selection.endOffset}get anchorKey(){return this.selection.anchorKey}get focusKey(){return this.selection.focusKey}get anchorOffset(){return this.selection.anchorOffset}get focusOffset(){return this.selection.focusOffset}get startBlock(){return this.startKey&&this.document.getClosestBlock(this.startKey)}get endBlock(){return this.endKey&&this.document.getClosestBlock(this.endKey)}get anchorBlock(){return this.anchorKey&&this.document.getClosestBlock(this.anchorKey)}get focusBlock(){return this.focusKey&&this.document.getClosestBlock(this.focusKey)}get startInline(){return this.startKey&&this.document.getClosestInline(this.startKey)}get endInline(){return this.endKey&&this.document.getClosestInline(this.endKey)}get anchorInline(){return this.anchorKey&&this.document.getClosestInline(this.anchorKey)}get focusInline(){return this.focusKey&&this.document.getClosestInline(this.focusKey)}get startText(){return this.startKey&&this.document.getDescendant(this.startKey)}get endText(){return this.endKey&&this.document.getDescendant(this.endKey)}get anchorText(){return this.anchorKey&&this.document.getDescendant(this.anchorKey)}get focusText(){return this.focusKey&&this.document.getDescendant(this.focusKey)}get nextBlock(){return this.endKey&&this.document.getNextBlock(this.endKey)}get previousBlock(){return this.startKey&&this.document.getPreviousBlock(this.startKey)}get nextInline(){return this.endKey&&this.document.getNextInline(this.endKey)}get previousInline(){return this.startKey&&this.document.getPreviousInline(this.startKey)}get nextText(){return this.endKey&&this.document.getNextText(this.endKey)}get previousText(){return this.startKey&&this.document.getPreviousText(this.startKey)}get characters(){return this.selection.isUnset?new c.List:this.document.getCharactersAtRange(this.selection)}get marks(){return this.selection.isUnset?new c.Set:this.selection.marks||this.document.getMarksAtRange(this.selection)}get activeMarks(){return this.selection.isUnset?new c.Set:this.selection.marks||this.document.getActiveMarksAtRange(this.selection)}get blocks(){return this.selection.isUnset?new c.List:this.document.getBlocksAtRange(this.selection)}get fragment(){return this.selection.isUnset?$.create():this.document.getFragmentAtRange(this.selection)}get inlines(){return this.selection.isUnset?new c.List:this.document.getInlinesAtRange(this.selection)}get texts(){return this.selection.isUnset?new c.List:this.document.getTextsAtRange(this.selection)}get isEmpty(){return!!this.isCollapsed||(0==this.endOffset||0==this.startOffset)&&this.fragment.isEmpty}get isInVoid(){return!this.isExpanded&&this.document.hasVoidParent(this.startKey)}change(e){return void 0===e&&(e={}),new We(b({},e,{value:this}))}toJS(e){void 0===e&&(e={});const t={object:this.object,document:this.document.toJS(e)};if(e.preserveData&&(t.data=this.data.toJS()),e.preserveDecorations&&(t.decorations=this.decorations?this.decorations.toArray().map(e=>e.toJS()):null),e.preserveHistory&&(t.history=this.history.toJS()),e.preserveSelection&&(t.selection=this.selection.toJS()),e.preserveSchema&&(t.schema=this.schema.toJS()),e.preserveSelection&&!e.preserveKeys){const e=this.document,s=this.selection;t.selection.anchorPath=s.isSet?e.getPath(s.anchorKey):null,t.selection.focusPath=s.isSet?e.getPath(s.focusKey):null,delete t.selection.anchorKey,delete t.selection.focusKey}if(e.preserveDecorations&&t.decorations&&!e.preserveKeys){const e=this.document;t.decorations=t.decorations.map(t=>{const s=b({},t,{anchorPath:e.getPath(t.anchorKey),focusPath:e.getPath(t.focusKey)});return delete s.anchorKey,delete s.focusKey,s})}return t}toJSON(e){return i.a.deprecate("slate@0.35.0","toJSON methods are deprecated, use toJS instead"),this.toJS(e)}}we.prototype[w.VALUE]=!0;const Ne={length:void 0,mark:void 0,marks:void 0,newPath:void 0,node:void 0,offset:void 0,path:void 0,position:void 0,properties:void 0,selection:void 0,target:void 0,text:void 0,type:void 0,value:void 0};class Ee extends(Object(c.Record)(Ne)){static create(e){if(void 0===e&&(e={}),Ee.isOperation(e))return e;if(a()(e))return Ee.fromJS(e);throw new Error(`\`Operation.create\` only accepts objects or operations, but you passed it: ${e}`)}static createList(e){if(void 0===e&&(e=[]),c.List.isList(e)||Array.isArray(e)){return new c.List(e.map(Ee.create))}throw new Error(`\`Operation.createList\` only accepts arrays or lists, but you passed it: ${e}`)}static fromJS(e){if(Ee.isOperation(e))return e;const t=e.type,s=e.value,r=ge[t],n={type:t};if(!r)throw new Error(`\`Operation.fromJS\` was passed an unrecognized operation type: "${t}"`);for(const o of r){let r=e[o];if(void 0===r){if("document"==o)continue;if("selection"==o)continue;if("value"==o)continue;if("node"==o&&"insert_node"!=t)continue;throw new Error(`\`Operation.fromJS\` was passed a "${t}" operation without the required "${o}" attribute.`)}if("mark"==o&&(r=R.create(r)),"marks"==o&&null!=r&&(r=R.createSet(r)),"node"==o&&(r=te.create(r)),"selection"==o&&(r=H.create(r)),"value"==o&&(r=we.create(r)),"properties"==o&&"merge_node"==t&&(r=te.createProperties(r)),"properties"==o&&"set_mark"==t&&(r=R.createProperties(r)),"properties"==o&&"set_node"==t&&(r=te.createProperties(r)),"properties"==o&&"set_selection"==t){const e=r,t=e.anchorKey,n=e.focusKey,o=S(e,["anchorKey","focusKey"]);r=H.createProperties(o),void 0!==t&&(r.anchorPath=null===t?null:s.document.getPath(t)),void 0!==n&&(r.focusPath=null===n?null:s.document.getPath(n))}"properties"==o&&"set_value"==t&&(r=we.createProperties(r)),"properties"==o&&"split_node"==t&&(r=te.createProperties(r)),n[o]=r}return new Ee(n)}static fromJSON(e){return i.a.deprecate("slate@0.35.0","fromJSON methods are deprecated, use fromJS instead"),Ee.fromJS(e)}static isOperation(e){return!(!e||!e[w.OPERATION])}static isOperationList(e){return c.List.isList(e)&&e.every(e=>Ee.isOperation(e))}get object(){return"operation"}get kind(){return i.a.deprecate("slate@0.32.0","The `kind` property of Slate objects has been renamed to `object`."),this.object}toJS(e){void 0===e&&(e={});const t=this.object,s=this.type,r={object:t,type:s},n=ge[s];for(const o of n){let e=this[o];if("document"!=o&&("selection"!=o&&"value"!=o&&("node"!=o||"insert_node"==s))){if("mark"!=o&&"marks"!=o&&"node"!=o||(e=e.toJS()),"properties"==o&&"merge_node"==s){const t={};"data"in e&&(t.data=e.data.toJS()),"type"in e&&(t.type=e.type),e=t}if("properties"==o&&"set_mark"==s){const t={};"data"in e&&(t.data=e.data.toJS()),"type"in e&&(t.type=e.type),e=t}if("properties"==o&&"set_node"==s){const t={};"data"in e&&(t.data=e.data.toJS()),"isVoid"in e&&(t.isVoid=e.isVoid),"type"in e&&(t.type=e.type),e=t}if("properties"==o&&"set_selection"==s){const t={};"anchorOffset"in e&&(t.anchorOffset=e.anchorOffset),"anchorPath"in e&&(t.anchorPath=e.anchorPath),"focusOffset"in e&&(t.focusOffset=e.focusOffset),"focusPath"in e&&(t.focusPath=e.focusPath),"isBackward"in e&&(t.isBackward=e.isBackward),"isFocused"in e&&(t.isFocused=e.isFocused),"marks"in e&&(t.marks=null==e.marks?null:e.marks.toJS()),e=t}if("properties"==o&&"set_value"==s){const t={};"data"in e&&(t.data=e.data.toJS()),"decorations"in e&&(t.decorations=e.decorations.toJS()),"schema"in e&&(t.schema=e.schema.toJS()),e=t}if("properties"==o&&"split_node"==s){const t={};"data"in e&&(t.data=e.data.toJS()),"type"in e&&(t.type=e.type),e=t}r[o]=e}}return r}toJSON(e){return i.a.deprecate("slate@0.35.0","toJSON methods are deprecated, use toJS instead"),this.toJS(e)}}Ee.prototype[w.OPERATION]=!0;const Fe=d()("slate:operation:invert");function Le(e){const t=(e=Ee.create(e)).type;if(Fe(t,e),"insert_node"==t){return e.set("type","remove_node")}if("remove_node"==t){return e.set("type","insert_node")}if("move_node"==t){const t=e,s=t.newPath,r=t.path;let n=s,o=r;const a=r.length-1,i=s.length-1;return r.length<n.length&&r.slice(0,a).every((e,t)=>e==n[t])&&r[a]<n[a]&&(n=n.slice(0,a).concat([n[a]-1]).concat(n.slice(a+1,n.length))),s.length<o.length&&s.slice(0,i).every((e,t)=>e==o[t])&&s[i]<=o[i]&&(o=o.slice(0,i).concat([o[i]+1]).concat(o.slice(i+1,o.length))),e.set("path",n).set("newPath",o)}if("merge_node"==t){const t=e.path,s=t.length-1,r=t.slice(0,s).concat([t[s]-1]);return e.set("type","split_node").set("path",r)}if("split_node"==t){const t=e.path,s=t.length-1,r=t.slice(0,s).concat([t[s]+1]);return e.set("type","merge_node").set("path",r)}if("set_node"==t){const t=e,s=t.properties,r=t.node,n=r.merge(s),o=h()(r,Object.keys(s));return e.set("node",n).set("properties",o)}if("insert_text"==t){return e.set("type","remove_text")}if("remove_text"==t){return e.set("type","insert_text")}if("add_mark"==t){return e.set("type","remove_mark")}if("remove_mark"==t){return e.set("type","add_mark")}if("set_mark"==t){const t=e,s=t.properties,r=t.mark,n=r.merge(s),o=h()(r,Object.keys(s));return e.set("mark",n).set("properties",o)}if("set_selection"==t){const t=e,s=t.properties,r=t.selection,n=t.value,o=s.anchorPath,a=s.focusPath,i=S(s,["anchorPath","focusPath"]),c=n.document;void 0!==o&&(i.anchorKey=null===o?null:c.assertPath(o).key),void 0!==a&&(i.focusKey=null===a?null:c.assertPath(a).key);const l=r.merge(i),d=h()(r,Object.keys(i));return void 0!==o&&(d.anchorPath=null===d.anchorKey?null:c.getPath(d.anchorKey),delete d.anchorKey),void 0!==a&&(d.focusPath=null===d.focusKey?null:c.getPath(d.focusKey),delete d.focusKey),e.set("selection",l).set("properties",d)}if("set_value"==t){const t=e,s=t.properties,r=t.value,n=r.merge(s),o=h()(r,Object.keys(s));return e.set("value",n).set("properties",o)}}const je={redo:e=>{let t=e.value,s=t.history;if(!s)return;let r=s,n=r.undos,o=r.redos;const a=o.peek();a&&(o=o.pop(),n=n.push(a),a.forEach(t=>{const s=t,r=s.type,n=s.properties;"set_selection"==r&&(t=t.set("properties",x()(n,"isFocused"))),e.applyOperation(t,{save:!1})}),t=e.value,s=s.set("undos",n).set("redos",o),t=t.set("history",s),e.value=t)},undo:e=>{let t=e.value,s=t.history;if(!s)return;let r=s,n=r.undos,o=r.redos;const a=n.peek();a&&(n=n.pop(),o=o.push(a),a.slice().reverse().map(Le).forEach(t=>{const s=t,r=s.type,n=s.properties;"set_selection"==r&&(t=t.set("properties",x()(n,"isFocused"))),e.applyOperation(t,{save:!1})}),t=e.value,s=s.set("undos",n).set("redos",o),t=t.set("history",s),e.value=t)}},ze={select:function(e,t,s){void 0===s&&(s={}),t=H.createProperties(t);const r=s.snapshot,n=void 0!==r&&r,o=e.value,a=o.document,i=o.selection,c={},l=i.toJS(),d=i.merge(t).normalize(a);t=h()(d,Object.keys(t));for(const h in t)0==n&&t[h]==l[h]||(c[h]=t[h]);const u=["anchorKey","anchorOffset","focusKey","focusOffset"].some(e=>c.hasOwnProperty(e));l.marks&&t.marks==l.marks&&u&&(c.marks=null),K()(c)||e.applyOperation({type:"set_selection",value:o,properties:c,selection:l},n?{skip:!1,merge:!1}:{})},selectAll:e=>{const t=e.value,s=t.document,r=t.selection.moveToRangeOf(s);e.select(r)},snapshotSelection:e=>{const t=e.value.selection;e.select(t,{snapshot:!0})},moveAnchorCharBackward:e=>{const t=e.value,s=t.document,r=t.selection,n=t.anchorText,o=t.anchorBlock,a=r.anchorOffset,i=s.getPreviousText(n.key),c=s.hasVoidParent(n.key),l=i&&s.hasVoidParent(i.key);!c&&a>0?e.moveAnchor(-1):i&&(e.moveAnchorToEndOf(i),c||l||!o.hasNode(i.key)||e.moveAnchor(-1))},moveAnchorCharForward:e=>{const t=e.value,s=t.document,r=t.selection,n=t.anchorText,o=t.anchorBlock,a=r.anchorOffset,i=s.getNextText(n.key),c=s.hasVoidParent(n.key),l=i&&s.hasVoidParent(i.key);!c&&a<n.text.length?e.moveAnchor(1):i&&(e.moveAnchorToStartOf(i),c||l||!o.hasNode(i.key)||e.moveAnchor(1))},moveFocusCharBackward:e=>{const t=e.value,s=t.document,r=t.selection,n=t.focusText,o=t.focusBlock,a=r.focusOffset,i=s.getPreviousText(n.key),c=s.hasVoidParent(n.key),l=i&&s.hasVoidParent(i.key);!c&&a>0?e.moveFocus(-1):i&&(e.moveFocusToEndOf(i),c||l||!o.hasNode(i.key)||e.moveFocus(-1))},moveFocusCharForward:e=>{const t=e.value,s=t.document,r=t.selection,n=t.focusText,o=t.focusBlock,a=r.focusOffset,i=s.getNextText(n.key),c=s.hasVoidParent(n.key),l=i&&s.hasVoidParent(i.key);!c&&a<n.text.length?e.moveFocus(1):i&&(e.moveFocusToStartOf(i),c||l||!o.hasNode(i.key)||e.moveFocus(1))}};["Forward","Backward"].forEach(e=>{const t=`moveAnchorChar${e}`,s=`moveFocusChar${e}`;ze[`moveChar${e}`]=(e=>{e[t]()[s]()}),ze[`moveStartChar${e}`]=(e=>{e.value.isBackward?e[s]():e[t]()}),ze[`moveEndChar${e}`]=(e=>{e.value.isBackward?e[t]():e[s]()}),ze[`extendChar${e}`]=(t=>{t[`moveFocusChar${e}`]()}),ze[`collapseChar${e}`]=(t=>{t["Forward"==e?"collapseToEnd":"collapseToStart"]()[`moveChar${e}`]()})});[["collapseLineBackward","collapseToStartOfBlock"],["collapseLineForward","collapseToEndOfBlock"],["extendLineBackward","extendToStartOfBlock"],["extendLineForward","extendToEndOfBlock"]].forEach(e=>{let t=e[0],s=e[1];ze[t]=function(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];e[s](e,...r)}});["blur","collapseTo","collapseToAnchor","collapseToEnd","collapseToEndOf","collapseToFocus","collapseToStart","collapseToStartOf","extend","extendTo","extendToEndOf","extendToStartOf","flip","focus","move","moveAnchor","moveAnchorOffsetTo","moveAnchorTo","moveAnchorToEndOf","moveAnchorToStartOf","moveEnd","moveEndOffsetTo","moveEndTo","moveFocus","moveFocusOffsetTo","moveFocusTo","moveFocusToEndOf","moveFocusToStartOf","moveOffsetsTo","moveStart","moveStartOffsetTo","moveStartTo","moveTo","moveToEnd","moveToEndOf","moveToRangeOf","moveToStart","moveToStartOf","deselect"].forEach(e=>{ze[e]=function(t){const s="deselect"!=e,r=t.value,n=r.document,o=r.selection;for(var a=arguments.length,i=new Array(a>1?a-1:0),c=1;c<a;c++)i[c-1]=arguments[c];let l=o[e](...i);s&&(l=l.normalize(n)),t.select(l)}});const Ce=["Next","Previous"],Pe=["Block","Inline","Text"];["moveTo","moveAnchorTo","moveFocusTo","moveStartTo","moveEndTo","collapseTo","extendTo"].forEach(e=>{const t=["Start","End"];"moveTo"==e&&t.push("Range"),t.forEach(t=>{const s=`${e}${t}Of`;Pe.forEach(e=>{const t="Text"==e?"getNode":`getClosest${e}`;ze[`${s}${e}`]=(e=>{const r=e.value,n=r.document,o=r.selection,a=n[t](o.startKey);a&&e[s](a)}),Ce.forEach(r=>{const n=`get${r}${e}`,o="Next"==r?"startKey":"endKey";ze[`${s}${r}${e}`]=(e=>{const r=e.value,a=r.document,i=r.selection,c=a[t](i[o]);if(!c)return;const l=a[n](c.key);l&&e[s](l)})})})})});const _e={setValue:function(e,t,s){void 0===s&&(s={}),t=we.createProperties(t);const r=e.value;e.applyOperation({type:"set_value",properties:t,value:r},s)}},De={};function Ie(e,t,s){const r=s.stack.plugins.length+1;let n=0;!function e(t,o){const a=o.validate(s);if(!a)return;let i=t.value.document.getPath(o.key);if(a(t),o=t.value.document.refindNode(i,o.key)){if(i=t.value.document.refindPath(i,o.key),++n>r)throw new Error("A schema rule could not be validated after sufficient iterations. This is usually due to a `rule.validate` or `rule.normalize` function of a schema being incorrectly written, causing an infinite loop.");e(t,o)}}(e,t)}De.normalize=(e=>{e.normalizeDocument()}),De.normalizeDocument=(e=>{const t=e.value.document;e.normalizeNodeByKey(t.key)}),De.normalizeNodeByKey=((e,t)=>{const s=e.value;let r=s.document,n=s.schema;const o=r.assertNode(t);!function e(t,s,r){if("text"==s.object)return void Ie(t,s,r);let n=s.getFirstInvalidDescendant(r);let o=t.value.document.getPath(s.key);for(;s&&n;)e(t,n,r),(s=t.value.document.refindNode(o,s.key))?(o=t.value.document.refindPath(o,s.key),n=s.getFirstInvalidDescendant(r)):(o=[],n=null);s&&Ie(t,s,r)}(e,o,n);const a=(r=e.value.document).getAncestors(t);a&&a.forEach(t=>{e.value.document.getDescendant(t.key)&&Ie(e,t,n)})});var Je=b({},M,fe,ye,je,ze,_e,De);const Re=d()("slate:operation:apply");function Me(e,t,s){if(e.selection&&t(e.selection)&&(e=e.set("selection",s(e.selection))),!e.decorations)return e;const r=e.decorations.map(e=>t(e)?s(e):e).filter(e=>null!==e.anchorKey);return e.set("decorations",r)}function Ve(e,t,s,r){return void 0===r&&(r=null),Me(e,e=>{if(!e.isAtomic)return!1;const n=e.startKey,o=e.startOffset,a=e.endKey,i=e.endOffset;return n==t&&o<s&&(a!=t||i>s)||r&&n==t&&o<r&&(a!=t||i>r)},e=>e.deselect())}const $e={add_mark(e,t){const s=t.path,r=t.offset,n=t.length,o=t.mark;let a=e.document,i=a.assertPath(s);return i=i.addMark(r,n,o),a=a.updateNode(i),e=e.set("document",a)},insert_node(e,t){const s=t.path,r=t.node,n=s[s.length-1],o=s.slice(0,-1);let a=e.document,i=a.assertPath(o);return i=i.insertNode(n,r),a=a.updateNode(i),e=e.set("document",a)},insert_text(e,t){const s=t.path,r=t.offset,n=t.text,o=t.marks;let a=e.document,i=a.assertPath(s);return i=i.insertText(r,n,o),a=a.updateNode(i),e=Me(e=Ve(e=e.set("document",a),i.key,r),e=>{let t=e.anchorKey,s=e.anchorOffset,n=e.isBackward,o=e.isAtomic;return t==i.key&&(s>r||s==r&&(!o||!n))},e=>e.moveAnchor(n.length)),e=Me(e,e=>{let t=e.focusKey,s=e.focusOffset,n=e.isBackward,o=e.isAtomic;return t==i.key&&(s>r||s==r&&(!o||n))},e=>e.moveFocus(n.length))},merge_node(e,t){const s=t.path,r=s.slice(0,s.length-1).concat([s[s.length-1]-1]);let n=e.document;const o=n.assertPath(r),a=n.assertPath(s);let i=n.getParent(o.key);const c=i.nodes.indexOf(o),l=i.nodes.indexOf(a);return i=i.mergeNode(c,l),n=n.updateNode(i),e=e.set("document",n),"text"==o.object&&(e=Me(e,e=>{let t=e.anchorKey,s=e.focusKey;return t==a.key||s==a.key},e=>(e.anchorKey==a.key&&(e=e.moveAnchorTo(o.key,o.text.length+e.anchorOffset)),e.focusKey==a.key&&(e=e.moveFocusTo(o.key,o.text.length+e.focusOffset)),e.normalize(n)))),e},move_node(e,t){const s=t.path,r=t.newPath,n=r[r.length-1],o=r.slice(0,-1),a=s.slice(0,-1),i=s[s.length-1];let c=e.document;const l=c.assertPath(s);let d,u=c.getParent(l.key);return u=u.removeNode(i),c=c.updateNode(u),a.every((e,t)=>e===o[t])&&a.length===o.length?d=u:a.every((e,t)=>e===o[t])&&i<o[a.length]?(o[a.length]--,d=c.assertPath(o)):d=c.assertPath(o),d=d.insertNode(n,l),c=c.updateNode(d),e=e.set("document",c)},remove_mark(e,t){const s=t.path,r=t.offset,n=t.length,o=t.mark;let a=e.document,i=a.assertPath(s);return i=i.removeMark(r,n,o),a=a.updateNode(i),e=e.set("document",a)},remove_node(e,t){const s=t.path;let r=e,n=r.document,o=r.selection;const a=n.assertPath(s);if(o.isSet||null!==e.decorations){const t="text"==a.object?a:a.getFirstText()||a,s="text"==a.object?a:a.getLastText()||a,r=n.getPreviousText(t.key),o=n.getNextText(s.key);e=Me(e,e=>{let t=e.startKey,s=e.endKey;return a.hasNode(t)||a.hasNode(s)},e=>{const t=e,s=t.startKey,i=t.endKey;return a.hasNode(s)&&(e=r?e.moveStartTo(r.key,r.text.length):o?e.moveStartTo(o.key,0):e.deselect()),a.hasNode(i)&&(e=r?e.moveEndTo(r.key,r.text.length):o?e.moveEndTo(o.key,0):e.deselect()),e.isSet?e.normalize(n):e})}let i=n.getParent(a.key);const c=i.nodes.indexOf(a);return i=i.removeNode(c),n=n.updateNode(i),e=e.set("document",n)},remove_text(e,t){const s=t.path,r=t.offset,n=t.text.length,o=r+n;let a=e.document,i=a.assertPath(s);return e=Me(e=Ve(e,i.key,r,r+n),e=>{return e.anchorKey==i.key},e=>e.anchorOffset>=o?e.moveAnchor(-n):e.anchorOffset>r?e.moveAnchorTo(e.anchorKey,r):e),e=Me(e,e=>{return e.focusKey==i.key},e=>e.focusOffset>=o?e.moveFocus(-n):e.focusOffset>r?e.moveFocusTo(e.focusKey,r):e),i=i.removeText(r,n),a=a.updateNode(i),e=e.set("document",a)},set_mark(e,t){const s=t.path,r=t.offset,n=t.length,o=t.mark,a=t.properties;let i=e.document,c=i.assertPath(s);return c=c.updateMark(r,n,o,a),i=i.updateNode(c),e=e.set("document",i)},set_node(e,t){const s=t.path,r=t.properties;let n=e.document,o=n.assertPath(s);return o=o.merge(r),n=n.updateNode(o),e=e.set("document",n)},set_selection(e,t){const s=t.properties,r=s.anchorPath,n=s.focusPath,o=S(s,["anchorPath","focusPath"]);let a=e,i=a.document,c=a.selection;return void 0!==r&&(o.anchorKey=null===r?null:i.assertPath(r).key),void 0!==n&&(o.focusKey=null===n?null:i.assertPath(n).key),c=(c=c.merge(o)).normalize(i),e=e.set("selection",c)},set_value(e,t){const s=t.properties;return e=e.merge(s)},split_node(e,t){const s=t.path,r=t.position,n=t.properties;let o=e.document;const a=o.assertPath(s);let i=o.getParent(a.key);const c=i.nodes.indexOf(a);if(i=i.splitNode(c,r),n){const e=i.nodes.get(c+1);"text"!==e.object&&(i=i.updateNode(e.merge(n)))}const l=(o=o.updateNode(i)).getNextText(a.key);return e=(e=Me(e,e=>{let t=e.startKey,s=e.startOffset,n=e.endKey,o=e.endOffset;return a.key==t&&r<=s||a.key==n&&r<=o},e=>{const t=e,s=t.startKey,n=t.startOffset,i=t.endKey,c=t.endOffset;let d=!1;return a.key==s&&r<=n&&(e=e.moveStartTo(l.key,n-r),d=!0),a.key==i&&r<=c&&(e=e.moveEndTo(l.key,c-r),d=!0),d?e.normalize(o):e})).set("document",o)}};function Ue(e,t){const s=(t=Ee.create(t)).type,r=$e[s];if(!r)throw new Error(`Unknown operation type: "${s}".`);return Re(s,t),e=r(e,t)}const He=d()("slate:change");class We{constructor(e){const t=e.value;this.value=t,this.operations=new c.List,this.flags=b({normalize:!0},h()(e,["merge","save","normalize"]))}get object(){return"change"}get kind(){return i.a.deprecate("slate@0.32.0","The `kind` property of Slate objects has been renamed to `object`."),this.object}applyOperation(e,t){void 0===t&&(t={});const s=this.operations,r=this.flags;let n=this.value,o=n.history;a()(e)&&(e=b({},e,{value:n})),e=Ee.create(e);const i=t=b({},r,t),c=i.merge,l=void 0===c?0!=s.size||null:c,d=i.save,u=void 0===d||d,h=i.skip,f=void 0===h?null:h;return He("apply",{operation:e,save:u,merge:l}),n=Ue(n,e),o&&u&&(o=o.save(e,{merge:l,skip:f}),n=n.set("history",o)),this.value=n,this.operations=s.push(e),this}applyOperations(e,t){return e.forEach(e=>this.applyOperation(e,t)),this}call(e){for(var t=arguments.length,s=new Array(t>1?t-1:0),r=1;r<t;r++)s[r-1]=arguments[r];return e(this,...s),this}withoutNormalization(e){const t=this.flags.normalize;this.setOperationFlag("normalize",!1);try{e(this),this.normalizeDocument()}finally{this.setOperationFlag("normalize",t)}return this}setOperationFlag(e,t){return this.flags[e]=t,this}getFlag(e,t){return void 0===t&&(t={}),void 0!==t[e]?t[e]:this.flags[e]}unsetOperationFlag(e){return delete this.flags[e],this}}T(We,"isChange",N.bind(null,"CHANGE")),We.prototype[w.CHANGE]=!0,Object.keys(Je).forEach(e=>{We.prototype[e]=function(){for(var t=arguments.length,s=new Array(t),r=0;r<t;r++)s[r]=arguments[r];return He(e,{args:s}),this.call(Je[e],...s),this}});var qe={apply:Ue,invert:Le},Ge={Block:P,Changes:Je,Character:Y,Data:I,Document:$,History:ke,Inline:D,Leaf:Q,Mark:R,Node:te,Operation:Ee,Operations:qe,Range:H,Schema:Ke,Stack:Oe,Text:ee,Value:we,resetKeyGenerator:z,setKeyGenerator:j,resetMemoization:r.resetMemoization,useMemoization:r.useMemoization};t.default=Ge}}]);